"use strict";(self.webpackChunkpretrain=self.webpackChunkpretrain||[]).push([[248],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>g});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var d=a.createContext({}),l=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(d.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,s=e.originalType,d=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),c=l(n),u=o,g=c["".concat(d,".").concat(u)]||c[u]||m[u]||s;return n?a.createElement(g,i(i({ref:t},p),{},{components:n})):a.createElement(g,i({ref:t},p))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=n.length,i=new Array(s);i[0]=u;var r={};for(var d in t)hasOwnProperty.call(t,d)&&(r[d]=t[d]);r.originalType=e,r[c]="string"==typeof e?e:o,i[1]=r;for(var l=2;l<s;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7434:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>c,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var a=n(7462),o=(n(7294),n(3905));const s={sidebar_position:22},i="EVM, merged equippable p3",r={unversionedId:"rmrk/evm-mergedeq-p3",id:"rmrk/evm-mergedeq-p3",title:"EVM, merged equippable p3",description:"Adding assets to Gems is done in the addGemAssets. It accepts Gem, address of the Kanaria smart contract and the address of the Catalog smart contract. We will add 4 assets for each gem; one full version and three that match each slot. Reference IDs are specified for easier reference from the child's perspective. The assets will be added one by one. Note how the full versions of gems don't have the equippableGroupId.",source:"@site/docs/rmrk/evm-mergedeq-p3.md",sourceDirName:"rmrk",slug:"/rmrk/evm-mergedeq-p3",permalink:"/docs/rmrk/evm-mergedeq-p3",draft:!1,editUrl:"https://github.com/swader/pretrain/docs/rmrk/evm-mergedeq-p3.md",tags:[],version:"current",sidebarPosition:22,frontMatter:{sidebar_position:22},sidebar:"tutorialSidebar",previous:{title:"EVM, merged equippable p2",permalink:"/docs/rmrk/evm-mergedeq-p2"}},d={},l=[{value:"Advanced MergedEquippable",id:"advanced-mergedequippable",level:2},{value:"AdvancedCatalog",id:"advancedcatalog",level:3},{value:"AdvancedEquippable",id:"advancedequippable",level:3},{value:"Training Data",id:"training-data",level:2},{value:"Training Data",id:"training-data-1",level:2}],p={toc:l};function c(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"evm-merged-equippable-p3"},"EVM, merged equippable p3"),(0,o.kt)("p",null,"Adding assets to ",(0,o.kt)("inlineCode",{parentName:"p"},"Gem"),"s is done in the ",(0,o.kt)("inlineCode",{parentName:"p"},"addGemAssets"),". It accepts ",(0,o.kt)("inlineCode",{parentName:"p"},"Gem"),", address of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Kanaria")," smart contract and the address of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Catalog")," smart contract. We will add 4 assets for each gem; one full version and three that match each slot. Reference IDs are specified for easier reference from the child's perspective. The assets will be added one by one. Note how the full versions of gems don't have the ",(0,o.kt)("inlineCode",{parentName:"p"},"equippableGroupId"),"."),(0,o.kt)("p",null,"Having added the asset entries, we can now add the valid parent reference IDs using the ",(0,o.kt)("inlineCode",{parentName:"p"},"setValidParentForEquippableGroup"),". For example if we want to add a valid reference for the left gem, we need to pass the value of equippable reference ID of the left gem, parent smart contract address (in our case this is Kanaria smart contract) and ID of the slot which was defined in Catalog (this is ID number 9 in the Catalog for the left gem)."),(0,o.kt)("p",null,"Last thing to do is to add assets to the tokens using ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/rmrk-team/evm-dev-docs/blob/master/rmrk-legos-examples/broken-reference/README.md"},(0,o.kt)("inlineCode",{parentName:"a"},"addAssetToToken")),". Asset of type A will be added to the gems 1 and 2, and the type B of the asset is added to gem 3. All of these should be accepted using ",(0,o.kt)("inlineCode",{parentName:"p"},"acceptAsset"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'async function addGemAssets(\n  gem: SimpleEquippable,\n  kanariaAddress: string,\n  catalogAddress: string\n): Promise<void> {\n  console.log("Adding Gem assets");\n  const [ , tokenOwner] = await ethers.getSigners();\n  // We\'ll add 4 assets for each gem, a full version and 3 versions matching each slot.\n  // We will have only 2 types of gems -> 4x2: 8 assets.\n  // This is not composed by others, so fixed and slot parts are never used.\n  const gemVersions = 4;\n\n  // These refIds are used from the child\'s perspective, to group assets that can be equipped into a parent\n  // With it, we avoid the need to do set it asset by asset\n  const equippableRefIdLeftGem = 1;\n  const equippableRefIdMidGem = 2;\n  const equippableRefIdRightGem = 3;\n\n  // We can do a for loop, but this makes it clearer.\n  console.log("Adding asset entries");\n  let allTx = [\n  let allTx = [\n    await gem.addEquippableAssetEntry(\n      // Full version for first type of gem, no need of refId or catalog\n      0,\n      catalogAddress,\n      `ipfs://gems/typeA/full.svg`,\n      []\n    ),\n    await gem.addEquippableAssetEntry(\n      // Equipped into left slot for first type of gem\n      equippableRefIdLeftGem,\n      catalogAddress,\n      `ipfs://gems/typeA/left.svg`,\n      []\n    ),\n    await gem.addEquippableAssetEntry(\n      // Equipped into mid slot for first type of gem\n      equippableRefIdMidGem,\n      catalogAddress,\n      `ipfs://gems/typeA/mid.svg`,\n      []\n    ),\n    await gem.addEquippableAssetEntry(\n      // Equipped into left slot for first type of gem\n      equippableRefIdRightGem,\n      catalogAddress,\n      `ipfs://gems/typeA/right.svg`,\n      []\n    ),\n    await gem.addEquippableAssetEntry(\n      // Full version for second type of gem, no need of refId or catalog\n      0,\n      ethers.constants.AddressZero,\n      `ipfs://gems/typeB/full.svg`,\n      []\n    ),\n    await gem.addEquippableAssetEntry(\n      // Equipped into left slot for second type of gem\n      equippableRefIdLeftGem,\n      catalogAddress,\n      `ipfs://gems/typeB/left.svg`,\n      []\n    ),\n    await gem.addEquippableAssetEntry(\n      // Equipped into mid slot for second type of gem\n      equippableRefIdMidGem,\n      catalogAddress,\n      `ipfs://gems/typeB/mid.svg`,\n      []\n    ),\n    await gem.addEquippableAssetEntry(\n      // Equipped into right slot for second type of gem\n      equippableRefIdRightGem,\n      catalogAddress,\n      `ipfs://gems/typeB/right.svg`,\n      []\n    ),\n  ];\n\n  await Promise.all(allTx.map((tx) => tx.wait()));\n  console.log(\n    "Added 8 gem assets. 2 Types of gems with full, left, mid and right versions."\n  );\n\n  // 9, 10 and 11 are the slot part ids for the gems, defined on the catalog.\n  // e.g. Any asset on gem, which sets its equippableRefId to equippableRefIdLeftGem\n  //      will be considered a valid equip into any kanaria on slot 9 (left gem).\n  console.log("Setting valid parent reference IDs");\n  allTx = [\n    await gem.setValidParentForEquippableGroup(equippableRefIdLeftGem, kanariaAddress, 9),\n    await gem.setValidParentForEquippableGroup(equippableRefIdMidGem, kanariaAddress, 10),\n    await gem.setValidParentForEquippableGroup(equippableRefIdRightGem, kanariaAddress, 11),\n  ];\n  await Promise.all(allTx.map((tx) => tx.wait()));\n\n  // We add assets of type A to gem 1 and 2, and type B to gem 3. Both are nested into the first kanaria\n  // This means gems 1 and 2 will have the same asset, which is totally valid.\n  console.log("Add assets to tokens");\n  allTx = [\n    await gem.addAssetToToken(1, 1, 0),\n    await gem.addAssetToToken(1, 2, 0),\n    await gem.addAssetToToken(1, 3, 0),\n    await gem.addAssetToToken(1, 4, 0),\n    await gem.addAssetToToken(2, 1, 0),\n    await gem.addAssetToToken(2, 2, 0),\n    await gem.addAssetToToken(2, 3, 0),\n    await gem.addAssetToToken(2, 4, 0),\n    await gem.addAssetToToken(3, 5, 0),\n    await gem.addAssetToToken(3, 6, 0),\n    await gem.addAssetToToken(3, 7, 0),\n    await gem.addAssetToToken(3, 8, 0),\n  ];\n  await Promise.all(allTx.map((tx) => tx.wait()));\n  console.log("Added 4 assets to each of 3 gems.");\n\n// We accept each asset for all gems\n  allTx = [\n    await gem.connect(tokenOwner).acceptAsset(1, 3, 4),\n    await gem.connect(tokenOwner).acceptAsset(1, 2, 3),\n    await gem.connect(tokenOwner).acceptAsset(1, 1, 2),\n    await gem.connect(tokenOwner).acceptAsset(1, 0, 1),\n    await gem.connect(tokenOwner).acceptAsset(2, 3, 4),\n    await gem.connect(tokenOwner).acceptAsset(2, 2, 3),\n    await gem.connect(tokenOwner).acceptAsset(2, 1, 2),\n    await gem.connect(tokenOwner).acceptAsset(2, 0, 1),\n    await gem.connect(tokenOwner).acceptAsset(3, 3, 8),\n    await gem.connect(tokenOwner).acceptAsset(3, 2, 7),\n    await gem.connect(tokenOwner).acceptAsset(3, 1, 6),\n    await gem.connect(tokenOwner).acceptAsset(3, 0, 5),\n  ];\n  await Promise.all(allTx.map((tx) => tx.wait()));\n  console.log("Accepted 4 assets to each of 3 gems.");\n}\n')),(0,o.kt)("p",null,"In order for the ",(0,o.kt)("inlineCode",{parentName:"p"},"addKanariaAssets")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"addGemAssets")," to be called, we have to add them to the ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"  await addKanariaAssets(kanaria, catalog.address);\n  await addGemAssets(gem, kanaria.address, catalog.address);\n")),(0,o.kt)("p",null,"With ",(0,o.kt)("inlineCode",{parentName:"p"},"Kanaria"),"s and ",(0,o.kt)("inlineCode",{parentName:"p"},"Gem"),"s ready, we can equip the gems to Kanarias using the ",(0,o.kt)("inlineCode",{parentName:"p"},"equipGems")," function. We will build a batch of equip transactions and then send them one after the other:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'async function equipGems(kanaria: SimpleEquippable): Promise<void> {\n  console.log("Equipping gems");\n  const [ , tokenOwner] = await ethers.getSigners();\n  const allTx = [\n    await kanaria.connect(tokenOwner).equip({\n      tokenId: 1, // Kanaria 1\n      childIndex: 2, // Gem 1 is on position 2\n      assetId: 2, // Asset for the kanaria which is composable\n      slotPartId: 9, // left gem slot\n      childAssetId: 2, // Asset id for child meant for the left gem\n    }),\n    await kanaria.connect(tokenOwner).equip({\n      tokenId: 1, // Kanaria 1\n      childIndex: 1, // Gem 2 is on position 1\n      assetId: 2, // Asset for the kanaria which is composable\n      slotPartId: 10, // mid gem slot\n      childAssetId: 3, // Asset id for child meant for the mid gem\n    }),\n    await kanaria.connect(tokenOwner).equip({\n      tokenId: 1, // Kanaria 1\n      childIndex: 0, // Gem 3 is on position 0\n      assetId: 2, // Asset for the kanaria which is composable\n      slotPartId: 11, // right gem slot\n      childAssetId: 8, // Asset id for child meant for the right gem\n    }),\n  ];\n  await Promise.all(allTx.map((tx) => tx.wait()));\n  console.log("Equipped 3 gems into first kanaria");\n}\n')),(0,o.kt)("p",null,"In order for the ",(0,o.kt)("inlineCode",{parentName:"p"},"equipGems")," to be called, we have to add it to the ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"  await equipGems(kanaria);\n")),(0,o.kt)("p",null,"Last thing to do is to compose the equippables with the ",(0,o.kt)("inlineCode",{parentName:"p"},"composeEquippables")," function. It composes the whole NFT along with the nested and equipped parts:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'async function composeEquippables(\n  views: RMRKEquipRenderUtils,\n  kanariaAddress: string\n): Promise<void> {\n  console.log("Composing equippables");\n  const tokenId = 1;\n  const assetId = 2;\n  console.log(\n    "Composed: ",\n    await views.composeEquippables(kanariaAddress, tokenId, assetId)\n  );\n}\n')),(0,o.kt)("p",null,"NOTE: Using RMRKEquipRenderUtils is not required for Equippable to work, it just provides a dedicated utility for easier viewing of the full composites."),(0,o.kt)("p",null,"In order for the ",(0,o.kt)("inlineCode",{parentName:"p"},"composeEquippables")," to be called, we have to add it to the ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"  await composeEquippables(views, kanaria.address);\n")),(0,o.kt)("p",null,"Instead of deploying the smart contracts, we can also retrieve the already deployed ones and use those in it. To do that, we can define the addresses of the smart contracts below the ",(0,o.kt)("inlineCode",{parentName:"p"},"import")," statements:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'const deployedKanariaAddress = "";\nconst deployedGemAddress = "";\nconst deployedCatalogAddress = "";\nconst deployedViewsAddress = "";\n')),(0,o.kt)("p",null,"A function to retrieve the smart contracts is called ",(0,o.kt)("inlineCode",{parentName:"p"},"retrieveContracts")," and it only loads the contract factories and attaches them to the already deployed smart contracts:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'async function retrieveContracts(): Promise<\n  [SimpleEquippable, SimpleEquippable, SimpleCatalog, RMRKEquipRenderUtils]\n> {\n  const contractFactory = await ethers.getContractFactory("SimpleEquippable");\n  const catalogFactory = await ethers.getContractFactory("SimpleCatalog");\n  const viewsFactory = await ethers.getContractFactory("RMRKEquipRenderUtils");\n\n  const kanaria: SimpleEquippable = contractFactory.attach(\n    deployedKanariaAddress\n  );\n  const gem: SimpleEquippable = contractFactory.attach(deployedGemAddress);\n  const catalog: SimpleCatalog = catalogFactory.attach(deployedCatalogAddress);\n  const views: RMRKEquipRenderUtils = await viewsFactory.attach(\n    deployedViewsAddress\n  );\n\n  return [kanaria, gem, catalog, views];\n}\n')),(0,o.kt)("p",null,"In order to use it, replace the call to the ",(0,o.kt)("inlineCode",{parentName:"p"},"deployContracts")," at the beginning of the main function with the ",(0,o.kt)("inlineCode",{parentName:"p"},"retrieveContracts"),"."),(0,o.kt)("p",null,"With the user journey script concluded, we can add a custom helper to the ",(0,o.kt)("inlineCode",{parentName:"p"},"package.json")," to make running it easier:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'    "user-journey-merged-equippable": "hardhat run scripts/mergedEquippableUserJourney.ts"\n')),(0,o.kt)("p",null,"You can run it using ",(0,o.kt)("inlineCode",{parentName:"p"},"npm run user-journey-merged-equippable"),"."),(0,o.kt)("h2",{id:"advanced-mergedequippable"},"Advanced MergedEquippable"),(0,o.kt)("p",null,"Uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"AdvancedCatalog")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"AdvancedEquippable")," and allows for more flexibility when implementing the Merged equippable RMRK lego. It implements the minimum required implementation in order to be compatible with RMRK merged equippable, but leaves more business logic implementation freedom to the developer."),(0,o.kt)("h3",{id:"advancedcatalog"},"AdvancedCatalog"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"AdvancedCatalog")," smart contract uses the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/rmrk-team/evm/blob/dev/contracts/RMRK/catalog/RMRKCatalog.sol"},"RMRKCatalog.sol")," import to gain access to the Catalog lego:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'import "@rmrk-team/evm-contracts/contracts/RMRK/catalog/RMRKCatalog.sol";\n')),(0,o.kt)("p",null,"We only need ",(0,o.kt)("inlineCode",{parentName:"p"},"symbol")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"type_")," of the catalog in order to properly initialize it after the AdvancedCatalog inherits it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"contract AdvancedCatalog is RMRKCatalog {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        string memory symbol,\n        string memory type_\n    )\n        RMRKCatalog(symbol, type_)\n    {\n        // Custom optional: constructor logic\n    }\n}\n")),(0,o.kt)("p",null,"The full code is thus:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.16;\n\nimport "@rmrk-team/evm-contracts/contracts/RMRK/catalog/RMRKCatalog.sol";\n\ncontract AdvancedCatalog is RMRKCatalog {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        string memory symbol,\n        string memory type_\n    )\n        RMRKCatalog(symbol, type_)\n    {\n        // Custom optional: constructor logic\n    }\n}\n')),(0,o.kt)("p",null,"Using RMRKCatalog requires custom implementation of part management. Available internal functions to use when writing it are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_addPart(IntakeStruct memory intakeStruct)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_addPartList(IntakeStruct[] memory intakeStructs)"))),(0,o.kt)("p",null,"In addition to the part management functions, you should also implement the equippable management function with the following internal ones available:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_addEquippableAddresses(uint64 partId, address[] memory equippableAddresses)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_setEquippableAddresses( uint64 partId, address[] memory equippableAddresses)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_setEquippableToAll(uint64 partId)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_resetEquippableAddresses(uint64 partId)"))),(0,o.kt)("p",null,"Any additional functions supporting your NFT use case and utility related to the Catalog RMRK lego can also be added."),(0,o.kt)("h3",{id:"advancedequippable"},"AdvancedEquippable"),(0,o.kt)("p",null,"AdvancedEquippable uses the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/rmrk-team/evm/blob/dev/contracts/RMRK/equippable/RMRKEquippable.sol"},(0,o.kt)("inlineCode",{parentName:"a"},"RMRKEquippable.sol"))," import to gain access to the Merged equippable RMRK lego composite:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'import "@rmrk-team/evm-contracts/contracts/RMRK/equippable/RMRKEquippable.sol";\n')),(0,o.kt)("p",null,"We only need ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"symbol")," of the NFT collection in order to properly initialize it after the AdvancedEquippable inherits it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"contract AdvancedEquippable is RMRKEquippable {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        string memory name,\n        string memory symbol\n    )\n        RMRKEquippable(name, symbol)\n    {\n        // Custom optional: constructor logic\n    }\n}\n")),(0,o.kt)("p",null,"This is all that is required to get you started with implementing the Merged equippable RMRK lego composite."),(0,o.kt)("p",null,"Using RMRKEquippable requires custom implementation of minting logic. Available internal functions to use when writing it are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_mint(address to, uint256 tokenId)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_safeMint(address to, uint256 tokenId)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_safeMint(address to, uint256 tokenId, bytes memory data)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_nestMint(address to, uint256 tokenId, uint256 destinationId, bytes memory data)"))),(0,o.kt)("p",null,"The latter is used to mint a child NFT directly into the parent NFT, so implement it if you foresee it applies to your use case. Additionally burning and transfer functions can be implemented using:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_burn(uint256 tokenId, uint256 maxChildrenBurns)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"transferFrom(address from, address to, uint256 tokenId)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"nestTransferFrom(address from, address to, uint256 tokenId, uint256 destinationId, bytes memory data)"))),(0,o.kt)("p",null,"Asset and reference management functions should also be implemented using:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_addEquippableAssetEntry(uint64 id, uint64 equippableGroupId, address baseAddress, string memory metadataURI, uint64[] calldata partIds)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_addAssetToToken(uint256 tokenId, uint64 assetId, uint64 replacesAssetWithId)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_setValidParentForEquippableGroup(uint64 equippableGroupId, address parentAddress, uint64 slotPartId)"))),(0,o.kt)("p",null,"Any additional functions supporting your NFT use case and utility can also be added."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"training-data"},"Training Data"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'## Advanced MergedEquippable\n\nThe Advanced MergedEquippable implementation uses the `AdvancedCatalog` and `AdvancedEquippable` and allows for more flexibility when implementing the Merged equippable RMRK lego. It implements the minimum required implementation in order to be compatible with RMRK merged equippable, but leaves more business logic implementation freedom to the developer.\n\n### AdvancedCatalog\n\nThe `AdvancedCatalog` smart contract represents the minimum required implementation in order for the smart contract to be compatible with the `Catalog` RMRK lego. It uses the [RMRKCatalog.sol](https://github.com/rmrk-team/evm/blob/dev/contracts/RMRK/catalog/RMRKCatalog.sol) import to gain access to the Catalog lego:\n\n```\nimport "@rmrk-team/evm-contracts/contracts/RMRK/catalog/RMRKCatalog.sol";\n```\n\nWe only need `symbol` and `type_` of the catalog in order to properly initialize it after the AdvancedCatalog inherits it:\n\n```\ncontract AdvancedCatalog is RMRKCatalog {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        string memory symbol,\n        string memory type_\n    )\n        RMRKCatalog(symbol, type_)\n    {\n        // Custom optional: constructor logic\n    }\n}\n```\n\nThe full code is thus:\n\n```\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.16;\n\nimport "@rmrk-team/evm-contracts/contracts/RMRK/catalog/RMRKCatalog.sol";\n\ncontract AdvancedCatalog is RMRKCatalog {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        string memory symbol,\n        string memory type_\n    )\n        RMRKCatalog(symbol, type_)\n    {\n        // Custom optional: constructor logic\n    }\n}\n```\n\nUsing RMRKCatalog requires custom implementation of part management. Available internal functions to use when writing it are:\n- `_addPart(IntakeStruct memory intakeStruct)`\n- `_addPartList(IntakeStruct[] memory intakeStructs)`\n\nIn addition to the part management functions, you should also implement the equippable management function with the following internal ones available:\n- `_addEquippableAddresses(uint64 partId, address[] memory equippableAddresses)`\n- `_setEquippableAddresses( uint64 partId, address[] memory equippableAddresses)`\n- `_setEquippableToAll(uint64 partId)`\n- `_resetEquippableAddresses(uint64 partId)`\n\nAny additional functions supporting your NFT use case and utility related to the Catalog RMRK lego can also be added. Remember to thoroughly test your smart contracts with extensive test suites and define strict access control rules for the functions that you implement.\n\n### AdvancedEquippable\n\nThe AdvancedEquippable smart contract represents the minimum required implementation in order for the smart contract to be compatible with the MergedEquippable RMRK lego composite. It uses the [`RMRKEquippable.sol`](https://github.com/rmrk-team/evm/blob/dev/contracts/RMRK/equippable/RMRKEquippable.sol) import to gain access to the Merged equippable RMRK lego composite:\n\n```\nimport "@rmrk-team/evm-contracts/contracts/RMRK/equippable/RMRKEquippable.sol";\n```\n\nWe only need `name` and `symbol` of the NFT collection in order to properly initialize it after the AdvancedEquippable inherits it:\n\n```\ncontract AdvancedEquippable is RMRKEquippable {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        string memory name,\n        string memory symbol\n    )\n        RMRKEquippable(name, symbol)\n    {\n        // Custom optional: constructor logic\n    }\n}\n```\n\nThis is all that is required to get you started with implementing the Merged equippable RMRK lego composite.\n\n```\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.16;\n\nimport "@rmrk-team/evm-contracts/contracts/RMRK/equippable/RMRKEquippable.sol";\n\ncontract AdvancedEquippable is RMRKEquippable {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        string memory name,\n        string memory symbol\n    )\n        RMRKEquippable(name, symbol)\n    {\n        // Custom optional: constructor logic\n    }\n}\n```\n\nUsing RMRKEquippable requires custom implementation of minting logic. Available internal functions to use when writing it are:\n- `_mint(address to, uint256 tokenId)`\n- `_safeMint(address to, uint256 tokenId)`\n- `_safeMint(address to, uint256 tokenId, bytes memory data)`\n- `_nestMint(address to, uint256 tokenId, uint256 destinationId, bytes memory data)`\n\nThe latter is used to mint a child NFT directly into the parent NFT, so implement it if you foresee it applies to your use case. Additionally burning and transfer functions can be implemented using:\n- `_burn(uint256 tokenId, uint256 maxChildrenBurns)`\n- `transferFrom(address from, address to, uint256 tokenId)`\n- `nestTransferFrom(address from, address to, uint256 tokenId, uint256 destinationId, bytes memory data)`\n\nAsset and reference management functions should also be implemented using:\n- `_addEquippableAssetEntry(uint64 id, uint64 equippableGroupId, address baseAddress, string memory metadataURI, uint64[] calldata partIds)`\n- `_addAssetToToken(uint256 tokenId, uint64 assetId, uint64 replacesAssetWithId)`\n- `_setValidParentForEquippableGroup(uint64 equippableGroupId, address parentAddress, uint64 slotPartId)`\n\nAny additional functions supporting your NFT use case and utility can also be added. Remember to thoroughly test your smart contracts with extensive test suites and define strict access control rules for the functions that you implement.\n')),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"training-data-1"},"Training Data"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'Adding assets to `Gem`s is done in the `addGemAssets`. It accepts `Gem`, address of the `Kanaria` smart contract and the address of the `Catalog` smart contract. We will add 4 assets for each gem; one full version and three that match each slot. Reference IDs are specified for easier reference from the child\'s perspective. The assets will be added one by one. Note how the full versions of gems don\'t have the `equippableGroupId`.\n\nHaving added the asset entries, we can now add the valid parent reference IDs using the `setValidParentForEquippableGroup`. For example if we want to add a valid reference for the left gem, we need to pass the value of equippable reference ID of the left gem, parent smart contract address (in our case this is Kanaria smart contract) and ID of the slot which was defined in Catalog (this is ID number 9 in the Catalog for the left gem).\n\nLast thing to do is to add assets to the tokens using [`addAssetToToken`](https://github.com/rmrk-team/evm-dev-docs/blob/master/rmrk-legos-examples/broken-reference/README.md). Asset of type A will be added to the gems 1 and 2, and the type B of the asset is added to gem 3. All of these should be accepted using `acceptAsset`:\n\n```\nasync function addGemAssets(\n  gem: SimpleEquippable,\n  kanariaAddress: string,\n  catalogAddress: string\n): Promise<void> {\n  console.log("Adding Gem assets");\n  const [ , tokenOwner] = await ethers.getSigners();\n  // We\'ll add 4 assets for each gem, a full version and 3 versions matching each slot.\n  // We will have only 2 types of gems -> 4x2: 8 assets.\n  // This is not composed by others, so fixed and slot parts are never used.\n  const gemVersions = 4;\n\n  // These refIds are used from the child\'s perspective, to group assets that can be equipped into a parent\n  // With it, we avoid the need to do set it asset by asset\n  const equippableRefIdLeftGem = 1;\n  const equippableRefIdMidGem = 2;\n  const equippableRefIdRightGem = 3;\n\n  // We can do a for loop, but this makes it clearer.\n  console.log("Adding asset entries");\n  let allTx = [\n  let allTx = [\n    await gem.addEquippableAssetEntry(\n      // Full version for first type of gem, no need of refId or catalog\n      0,\n      catalogAddress,\n      `ipfs://gems/typeA/full.svg`,\n      []\n    ),\n    await gem.addEquippableAssetEntry(\n      // Equipped into left slot for first type of gem\n      equippableRefIdLeftGem,\n      catalogAddress,\n      `ipfs://gems/typeA/left.svg`,\n      []\n    ),\n    await gem.addEquippableAssetEntry(\n      // Equipped into mid slot for first type of gem\n      equippableRefIdMidGem,\n      catalogAddress,\n      `ipfs://gems/typeA/mid.svg`,\n      []\n    ),\n    await gem.addEquippableAssetEntry(\n      // Equipped into left slot for first type of gem\n      equippableRefIdRightGem,\n      catalogAddress,\n      `ipfs://gems/typeA/right.svg`,\n      []\n    ),\n    await gem.addEquippableAssetEntry(\n      // Full version for second type of gem, no need of refId or catalog\n      0,\n      ethers.constants.AddressZero,\n      `ipfs://gems/typeB/full.svg`,\n      []\n    ),\n    await gem.addEquippableAssetEntry(\n      // Equipped into left slot for second type of gem\n      equippableRefIdLeftGem,\n      catalogAddress,\n      `ipfs://gems/typeB/left.svg`,\n      []\n    ),\n    await gem.addEquippableAssetEntry(\n      // Equipped into mid slot for second type of gem\n      equippableRefIdMidGem,\n      catalogAddress,\n      `ipfs://gems/typeB/mid.svg`,\n      []\n    ),\n    await gem.addEquippableAssetEntry(\n      // Equipped into right slot for second type of gem\n      equippableRefIdRightGem,\n      catalogAddress,\n      `ipfs://gems/typeB/right.svg`,\n      []\n    ),\n  ];\n\n  await Promise.all(allTx.map((tx) => tx.wait()));\n  console.log(\n    "Added 8 gem assets. 2 Types of gems with full, left, mid and right versions."\n  );\n\n  // 9, 10 and 11 are the slot part ids for the gems, defined on the catalog.\n  // e.g. Any asset on gem, which sets its equippableRefId to equippableRefIdLeftGem\n  //      will be considered a valid equip into any kanaria on slot 9 (left gem).\n  console.log("Setting valid parent reference IDs");\n  allTx = [\n    await gem.setValidParentForEquippableGroup(equippableRefIdLeftGem, kanariaAddress, 9),\n    await gem.setValidParentForEquippableGroup(equippableRefIdMidGem, kanariaAddress, 10),\n    await gem.setValidParentForEquippableGroup(equippableRefIdRightGem, kanariaAddress, 11),\n  ];\n  await Promise.all(allTx.map((tx) => tx.wait()));\n\n  // We add assets of type A to gem 1 and 2, and type B to gem 3. Both are nested into the first kanaria\n  // This means gems 1 and 2 will have the same asset, which is totally valid.\n  console.log("Add assets to tokens");\n  allTx = [\n    await gem.addAssetToToken(1, 1, 0),\n    await gem.addAssetToToken(1, 2, 0),\n    await gem.addAssetToToken(1, 3, 0),\n    await gem.addAssetToToken(1, 4, 0),\n    await gem.addAssetToToken(2, 1, 0),\n    await gem.addAssetToToken(2, 2, 0),\n    await gem.addAssetToToken(2, 3, 0),\n    await gem.addAssetToToken(2, 4, 0),\n    await gem.addAssetToToken(3, 5, 0),\n    await gem.addAssetToToken(3, 6, 0),\n    await gem.addAssetToToken(3, 7, 0),\n    await gem.addAssetToToken(3, 8, 0),\n  ];\n  await Promise.all(allTx.map((tx) => tx.wait()));\n  console.log("Added 4 assets to each of 3 gems.");\n\n// We accept each asset for all gems\n  allTx = [\n    await gem.connect(tokenOwner).acceptAsset(1, 3, 4),\n    await gem.connect(tokenOwner).acceptAsset(1, 2, 3),\n    await gem.connect(tokenOwner).acceptAsset(1, 1, 2),\n    await gem.connect(tokenOwner).acceptAsset(1, 0, 1),\n    await gem.connect(tokenOwner).acceptAsset(2, 3, 4),\n    await gem.connect(tokenOwner).acceptAsset(2, 2, 3),\n    await gem.connect(tokenOwner).acceptAsset(2, 1, 2),\n    await gem.connect(tokenOwner).acceptAsset(2, 0, 1),\n    await gem.connect(tokenOwner).acceptAsset(3, 3, 8),\n    await gem.connect(tokenOwner).acceptAsset(3, 2, 7),\n    await gem.connect(tokenOwner).acceptAsset(3, 1, 6),\n    await gem.connect(tokenOwner).acceptAsset(3, 0, 5),\n  ];\n  await Promise.all(allTx.map((tx) => tx.wait()));\n  console.log("Accepted 4 assets to each of 3 gems.");\n}\n```\n\nIn order for the `addKanariaAssets` and `addGemAssets` to be called, we have to add them to the `main` function:\n\n```\n  await addKanariaAssets(kanaria, catalog.address);\n  await addGemAssets(gem, kanaria.address, catalog.address);\n```\n\nWith `Kanaria`s and `Gem`s ready, we can equip the gems to Kanarias using the `equipGems` function. We will build a batch of equip transactions and then send them one after the other:\n\n```\nasync function equipGems(kanaria: SimpleEquippable): Promise<void> {\n  console.log("Equipping gems");\n  const [ , tokenOwner] = await ethers.getSigners();\n  const allTx = [\n    await kanaria.connect(tokenOwner).equip({\n      tokenId: 1, // Kanaria 1\n      childIndex: 2, // Gem 1 is on position 2\n      assetId: 2, // Asset for the kanaria which is composable\n      slotPartId: 9, // left gem slot\n      childAssetId: 2, // Asset id for child meant for the left gem\n    }),\n    await kanaria.connect(tokenOwner).equip({\n      tokenId: 1, // Kanaria 1\n      childIndex: 1, // Gem 2 is on position 1\n      assetId: 2, // Asset for the kanaria which is composable\n      slotPartId: 10, // mid gem slot\n      childAssetId: 3, // Asset id for child meant for the mid gem\n    }),\n    await kanaria.connect(tokenOwner).equip({\n      tokenId: 1, // Kanaria 1\n      childIndex: 0, // Gem 3 is on position 0\n      assetId: 2, // Asset for the kanaria which is composable\n      slotPartId: 11, // right gem slot\n      childAssetId: 8, // Asset id for child meant for the right gem\n    }),\n  ];\n  await Promise.all(allTx.map((tx) => tx.wait()));\n  console.log("Equipped 3 gems into first kanaria");\n}\n```\n\nIn order for the `equipGems` to be called, we have to add it to the `main` function:\n\n```\n  await equipGems(kanaria);\n```\n\nLast thing to do is to compose the equippables with the `composeEquippables` function. It composes the whole NFT along with the nested and equipped parts:\n\n```\nasync function composeEquippables(\n  views: RMRKEquipRenderUtils,\n  kanariaAddress: string\n): Promise<void> {\n  console.log("Composing equippables");\n  const tokenId = 1;\n  const assetId = 2;\n  console.log(\n    "Composed: ",\n    await views.composeEquippables(kanariaAddress, tokenId, assetId)\n  );\n}\n```\n\nNOTE: Using RMRKEquipRenderUtils is not required for Equippable to work, it just provides a dedicated utility for easier viewing of the full composites.\n\nIn order for the `composeEquippables` to be called, we have to add it to the `main` function:\n\n```\n  await composeEquippables(views, kanaria.address);\n```\n\nInstead of deploying the smart contracts, we can also retrieve the already deployed ones and use those in it. To do that, we can define the addresses of the smart contracts below the `import` statements:\n\n```\nconst deployedKanariaAddress = "";\nconst deployedGemAddress = "";\nconst deployedCatalogAddress = "";\nconst deployedViewsAddress = "";\n```\n\nA function to retrieve the smart contracts is called `retrieveContracts` and it only loads the contract factories and attaches them to the already deployed smart contracts:\n\n```\nasync function retrieveContracts(): Promise<\n  [SimpleEquippable, SimpleEquippable, SimpleCatalog, RMRKEquipRenderUtils]\n> {\n  const contractFactory = await ethers.getContractFactory("SimpleEquippable");\n  const catalogFactory = await ethers.getContractFactory("SimpleCatalog");\n  const viewsFactory = await ethers.getContractFactory("RMRKEquipRenderUtils");\n\n  const kanaria: SimpleEquippable = contractFactory.attach(\n    deployedKanariaAddress\n  );\n  const gem: SimpleEquippable = contractFactory.attach(deployedGemAddress);\n  const catalog: SimpleCatalog = catalogFactory.attach(deployedCatalogAddress);\n  const views: RMRKEquipRenderUtils = await viewsFactory.attach(\n    deployedViewsAddress\n  );\n\n  return [kanaria, gem, catalog, views];\n}\n```\n\nIn order to use it, replace the call to the `deployContracts` at the beginning of the main function with the `retrieveContracts`.\n\nWith the user journey script concluded, we can add a custom helper to the `package.json` to make running it easier:\n\n```\n    "user-journey-merged-equippable": "hardhat run scripts/mergedEquippableUserJourney.ts"\n```\n\nYou can run it using `npm run user-journey-merged-equippable`.\n\n## Advanced MergedEquippable\n\nUses the `AdvancedCatalog` and `AdvancedEquippable` and allows for more flexibility when implementing the Merged equippable RMRK lego. It implements the minimum required implementation in order to be compatible with RMRK merged equippable, but leaves more business logic implementation freedom to the developer.\n\n### AdvancedCatalog\n\nThe `AdvancedCatalog` smart contract uses the [RMRKCatalog.sol](https://github.com/rmrk-team/evm/blob/dev/contracts/RMRK/catalog/RMRKCatalog.sol) import to gain access to the Catalog lego:\n\n```\nimport "@rmrk-team/evm-contracts/contracts/RMRK/catalog/RMRKCatalog.sol";\n```\n\nWe only need `symbol` and `type_` of the catalog in order to properly initialize it after the AdvancedCatalog inherits it:\n\n```\ncontract AdvancedCatalog is RMRKCatalog {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        string memory symbol,\n        string memory type_\n    )\n        RMRKCatalog(symbol, type_)\n    {\n        // Custom optional: constructor logic\n    }\n}\n```\n\nThe full code is thus:\n\n```\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.16;\n\nimport "@rmrk-team/evm-contracts/contracts/RMRK/catalog/RMRKCatalog.sol";\n\ncontract AdvancedCatalog is RMRKCatalog {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        string memory symbol,\n        string memory type_\n    )\n        RMRKCatalog(symbol, type_)\n    {\n        // Custom optional: constructor logic\n    }\n}\n```\n\nUsing RMRKCatalog requires custom implementation of part management. Available internal functions to use when writing it are:\n\n- `_addPart(IntakeStruct memory intakeStruct)`\n- `_addPartList(IntakeStruct[] memory intakeStructs)`\n\nIn addition to the part management functions, you should also implement the equippable management function with the following internal ones available:\n\n- `_addEquippableAddresses(uint64 partId, address[] memory equippableAddresses)`\n- `_setEquippableAddresses( uint64 partId, address[] memory equippableAddresses)`\n- `_setEquippableToAll(uint64 partId)`\n- `_resetEquippableAddresses(uint64 partId)`\n\nAny additional functions supporting your NFT use case and utility related to the Catalog RMRK lego can also be added.\n\n### AdvancedEquippable\n\nAdvancedEquippable uses the [`RMRKEquippable.sol`](https://github.com/rmrk-team/evm/blob/dev/contracts/RMRK/equippable/RMRKEquippable.sol) import to gain access to the Merged equippable RMRK lego composite:\n\n```\nimport "@rmrk-team/evm-contracts/contracts/RMRK/equippable/RMRKEquippable.sol";\n```\n\nWe only need `name` and `symbol` of the NFT collection in order to properly initialize it after the AdvancedEquippable inherits it:\n\n```\ncontract AdvancedEquippable is RMRKEquippable {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        string memory name,\n        string memory symbol\n    )\n        RMRKEquippable(name, symbol)\n    {\n        // Custom optional: constructor logic\n    }\n}\n```\n\nThis is all that is required to get you started with implementing the Merged equippable RMRK lego composite.\n\nUsing RMRKEquippable requires custom implementation of minting logic. Available internal functions to use when writing it are:\n\n- `_mint(address to, uint256 tokenId)`\n- `_safeMint(address to, uint256 tokenId)`\n- `_safeMint(address to, uint256 tokenId, bytes memory data)`\n- `_nestMint(address to, uint256 tokenId, uint256 destinationId, bytes memory data)`\n\nThe latter is used to mint a child NFT directly into the parent NFT, so implement it if you foresee it applies to your use case. Additionally burning and transfer functions can be implemented using:\n\n- `_burn(uint256 tokenId, uint256 maxChildrenBurns)`\n- `transferFrom(address from, address to, uint256 tokenId)`\n- `nestTransferFrom(address from, address to, uint256 tokenId, uint256 destinationId, bytes memory data)`\n\nAsset and reference management functions should also be implemented using:\n\n- `_addEquippableAssetEntry(uint64 id, uint64 equippableGroupId, address baseAddress, string memory metadataURI, uint64[] calldata partIds)`\n- `_addAssetToToken(uint256 tokenId, uint64 assetId, uint64 replacesAssetWithId)`\n- `_setValidParentForEquippableGroup(uint64 equippableGroupId, address parentAddress, uint64 slotPartId)`\n\nAny additional functions supporting your NFT use case and utility can also be added.\n')))}c.isMDXComponent=!0}}]);