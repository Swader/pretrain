"use strict";(self.webpackChunkpretrain=self.webpackChunkpretrain||[]).push([[5860],{3905:(t,e,n)=>{n.d(e,{Zo:()=>d,kt:()=>h});var s=n(7294);function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function a(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);e&&(s=s.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,s)}return n}function r(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?a(Object(n),!0).forEach((function(e){o(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function i(t,e){if(null==t)return{};var n,s,o=function(t,e){if(null==t)return{};var n,s,o={},a=Object.keys(t);for(s=0;s<a.length;s++)n=a[s],e.indexOf(n)>=0||(o[n]=t[n]);return o}(t,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);for(s=0;s<a.length;s++)n=a[s],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(o[n]=t[n])}return o}var l=s.createContext({}),c=function(t){var e=s.useContext(l),n=e;return t&&(n="function"==typeof t?t(e):r(r({},e),t)),n},d=function(t){var e=c(t.components);return s.createElement(l.Provider,{value:e},t.children)},p="mdxType",u={inlineCode:"code",wrapper:function(t){var e=t.children;return s.createElement(s.Fragment,{},e)}},m=s.forwardRef((function(t,e){var n=t.components,o=t.mdxType,a=t.originalType,l=t.parentName,d=i(t,["components","mdxType","originalType","parentName"]),p=c(n),m=o,h=p["".concat(l,".").concat(m)]||p[m]||u[m]||a;return n?s.createElement(h,r(r({ref:e},d),{},{components:n})):s.createElement(h,r({ref:e},d))}));function h(t,e){var n=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var a=n.length,r=new Array(a);r[0]=m;var i={};for(var l in e)hasOwnProperty.call(e,l)&&(i[l]=e[l]);i.originalType=t,i[p]="string"==typeof t?t:o,r[1]=i;for(var c=2;c<a;c++)r[c]=n[c];return s.createElement.apply(null,r)}return s.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1216:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var s=n(7462),o=(n(7294),n(3905));const a={sidebar_position:16},r="EVM, multi-asset part 2",i={unversionedId:"rmrk/evm-ma-2",id:"rmrk/evm-ma-2",title:"EVM, multi-asset part 2",description:"Deploy Script",source:"@site/docs/rmrk/evm-ma-2.md",sourceDirName:"rmrk",slug:"/rmrk/evm-ma-2",permalink:"/docs/rmrk/evm-ma-2",draft:!1,editUrl:"https://github.com/swader/pretrain/docs/rmrk/evm-ma-2.md",tags:[],version:"current",sidebarPosition:16,frontMatter:{sidebar_position:16},sidebar:"tutorialSidebar",previous:{title:"EVM, multi-asset part 1",permalink:"/docs/rmrk/evm-ma-1"},next:{title:"EVM, nestable part 1",permalink:"/docs/rmrk/evm-nestable-p1"}},l={},c=[{value:"Deploy Script",id:"deploy-script",level:2},{value:"User Journey",id:"user-journey",level:2},{value:"AdvancedMultiAsset",id:"advancedmultiasset",level:2},{value:"Training Data",id:"training-data",level:2}],d={toc:c};function p(t){let{components:e,...n}=t;return(0,o.kt)("wrapper",(0,s.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"evm-multi-asset-part-2"},"EVM, multi-asset part 2"),(0,o.kt)("h2",{id:"deploy-script"},"Deploy Script"),(0,o.kt)("p",null,"The deploy script for the ",(0,o.kt)("inlineCode",{parentName:"p"},"SimpleMultiAsset")," smart contract resides in ",(0,o.kt)("inlineCode",{parentName:"p"},"deployMultiAsset.ts"),"."),(0,o.kt)("p",null,"The script uses ",(0,o.kt)("inlineCode",{parentName:"p"},"ethers"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"SimpleMultiAsset")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ContractTransaction")," imports. The empty deploy script should look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'import { ethers } from "hardhat";\nimport { SimpleMultiAsset } from "../typechain-types";\nimport { ContractTransaction } from "ethers";\n\nasync function main() {\n\n}\n\nmain().catch((error) => {\n  console.error(error);\n  process.exitCode = 1;\n});\n')),(0,o.kt)("p",null,"Before we can deploy the parent and child smart contracts, we should prepare the constants that we will use in the script:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'  const pricePerMint = ethers.utils.parseEther("0.0001");\n  const totalTokens = 5;\n  const [owner] = await ethers.getSigners();\n')),(0,o.kt)("p",null,"Now that the constants are ready, we can deploy the smart contract and log the address of the contract to the console:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'  const contractFactory = await ethers.getContractFactory(\n    "SimpleMultiAsset"\n  );\n  const token: SimpleMultiAsset = await contractFactory.deploy(\n    {\n      erc20TokenAddress: ethers.constants.AddressZero,\n      tokenUriIsEnumerable: true,\n      royaltyRecipient: ethers.constants.AddressZero,\n      royaltyPercentageBps: 0,\n      maxSupply: 1000,\n      pricePerMint: pricePerMint \n    }\n  );\n\n  await token.deployed();\n  console.log(`Sample contract deployed to ${token.address}`);\n')),(0,o.kt)("p",null,"A custom script added to ",(0,o.kt)("inlineCode",{parentName:"p"},"package.json")," allows us to easily run the script:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'  "scripts": {\n    "deploy-multi-asset": "hardhat run scripts/deployMultiAsset.ts"\n  }\n')),(0,o.kt)("p",null,"Using the script with ",(0,o.kt)("inlineCode",{parentName:"p"},"npm run deploy-multi-asset")," should return the following output:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"npm run deploy-multi-asset\n\n> @rmrk-team/evm-contract-samples@0.1.0 deploy-multi-asset\n> hardhat run scripts/deployMultiAsset.ts\n\nCompiled 47 Solidity files successfully\nSample contract deployed to 0x5FbDB2315678afecb367f032d93F642f64180aa3\n")),(0,o.kt)("h2",{id:"user-journey"},"User Journey"),(0,o.kt)("p",null,"With the deploy script ready, we can examine how the journey of a user using multi asset would look like using this smart contract.\nThe base of it is the same as the deploy script, as we need to deploy the smart contract in order to interact with it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'import { ethers } from "hardhat";\nimport { SimpleMultiAsset } from "../typechain-types";\nimport { ContractTransaction } from "ethers";\n\nasync function main() {\n  const pricePerMint = ethers.utils.parseEther("0.0001");\n  const totalTokens = 5;\n  const [ , tokenOwner] = await ethers.getSigners();\n\n  const contractFactory = await ethers.getContractFactory(\n    "SimpleMultiAsset"\n  );\n  const token: SimpleMultiAsset = await contractFactory.deploy(\n    {\n      erc20TokenAddress: ethers.constants.AddressZero,\n      tokenUriIsEnumerable: true,\n      royaltyRecipient: ethers.constants.AddressZero,\n      royaltyPercentageBps: 0,\n      maxSupply: 1000,\n      pricePerMint: pricePerMint \n    }\n  );\n\n  await token.deployed();\n  console.log(`Sample contract deployed to ${token.address}`);\n}\n\nmain().catch((error) => {\n  console.error(error);\n  process.exitCode = 1;\n});\n')),(0,o.kt)("p",null,"NOTE: We assign the ",(0,o.kt)("inlineCode",{parentName:"p"},"tokenOwner")," the second available signer, so that the assets are not automatically accepted when added to the token. This happens when an account adding an asset to a token is also the owner of said token."),(0,o.kt)("p",null,"First thing that needs to be done after the smart contract is deployed it to mint the NFT. We will use the ",(0,o.kt)("inlineCode",{parentName:"p"},"totalTokens")," constant to specify how many tokens to mint:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'  console.log("Minting tokens");\n  let tx = await token.mint(tokenOwner.address, totalTokens, {\n    value: pricePerMint.mul(totalTokens),\n  });\n  await tx.wait();\n  console.log(`Minted ${totalTokens} tokens`);\n  const totalSupply = await token.totalSupply();\n  console.log("Total tokens: %s", totalSupply);\n')),(0,o.kt)("p",null,"Now that the tokens are minted, we can add new assets to the smart contract. We will prepare a batch of transactions that will add simple IPFS metadata link for the assets in the smart contract. Once the transactions are ready, we will send them and get all of the assets to output to the console:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'  console.log("Adding assets");\n  let allTx: ContractTransaction[] = [];\n  for (let i = 1; i <= totalTokens; i++) {\n    let tx = await token.addAssetEntry(`ipfs://metadata/${i}.json`);\n    allTx.push(tx);\n  }\n  console.log(`Added ${totalTokens} assets`);\n\n  console.log("Awaiting for all tx to finish...");\n  await Promise.all(allTx.map((tx) => tx.wait()));\n')),(0,o.kt)("p",null,"Once the assets are added to the smart contract we can assign each asset to one of the tokens:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'  console.log("Adding assets to tokens");\n  allTx = [];\n  for (let i = 1; i <= totalTokens; i++) {\n    // We give each token a asset id with the same number. This is just a coincidence, not a restriction.\n    let tx = await token.addAssetToToken(i, i, 0);\n    allTx.push(tx);\n    console.log(`Added asset ${i} to token ${i}.`);\n  }\n  console.log("Awaiting for all tx to finish...");\n  await Promise.all(allTx.map((tx) => tx.wait()));\n')),(0,o.kt)("p",null,"After the assets are added to the NFTs, we have to accept them. We will do this by once again building a batch of transactions for each of the tokens and send them at the end:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'  console.log("Accepting token assets");\n  allTx = [];\n  for (let i = 1; i <= totalTokens; i++) {\n    // Accept pending asset for each token (on index 0)\n    let tx = await token.connect(tokenOwner).acceptAsset(i, 0, i);\n    allTx.push(tx);\n    console.log(`Accepted first pending asset for token ${i}.`);\n  }\n  console.log("Awaiting for all tx to finish...");\n  await Promise.all(allTx.map((tx) => tx.wait()));\n')),(0,o.kt)("p",null,"NOTE: Accepting assets is done in a array that gets elements, new assets, appended to the end of it. Once the asset is accepted, the asset that was added last, takes its place. For example:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"We have assets A, B, C and D in the pending array organised like this: ","[A, B, C, D]","."),(0,o.kt)("li",{parentName:"ul"},"Accepting the asset A updates the array to look like this: ","[D, B, C]","."),(0,o.kt)("li",{parentName:"ul"},"Accepting the asset B updates the array to look like this: ","[A, D, C]",".")),(0,o.kt)("p",null,"Finally we can check wether the URI are assigned as expected and output the values to the console:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'  console.log("Getting URIs");\n  const uriToken1 = await token.tokenURI(1);\n  const uriFinalToken = await token.tokenURI(totalTokens);\n\n  console.log("Token 1 URI: ", uriToken1);\n  console.log("Token totalTokens URI: ", uriFinalToken);\n')),(0,o.kt)("p",null,"With the user journey script concluded, we can add a custom helper to the ",(0,o.kt)("inlineCode",{parentName:"p"},"package.json")," to make running it easier:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'    "user-journey-multi-asset": "hardhat run scripts/multiAssetUserJourney.ts"\n')),(0,o.kt)("p",null,"Running it using ",(0,o.kt)("inlineCode",{parentName:"p"},"npm run user-journey-multi-asset")," should return the following output:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},' npm run user-journey-multi-asset\n\n> @rmrk-team/evm-contract-samples@0.1.0 user-journey-multi-asset\n> hardhat run scripts/multiAssetUserJourney.ts\n\nSample contract deployed to 0x5FbDB2315678afecb367f032d93F642f64180aa3\nMinting tokens\nMinted 5 tokens\nTotal tokens: 5\nAdding assets\nAdded 5 assets\nAwaiting for all tx to finish...\nAll assets: [\n  BigNumber { value: "1" },\n  BigNumber { value: "2" },\n  BigNumber { value: "3" },\n  BigNumber { value: "4" },\n  BigNumber { value: "5" }\n]\nAdding assets to tokens\nAdded asset 1 to token 1.\nAdded asset 2 to token 2.\nAdded asset 3 to token 3.\nAdded asset 4 to token 4.\nAdded asset 5 to token 5.\nAwaiting for all tx to finish...\nAccepting token assets\nAccepted first pending asset for token 1.\nAccepted first pending asset for token 2.\nAccepted first pending asset for token 3.\nAccepted first pending asset for token 4.\nAccepted first pending asset for token 5.\nAwaiting for all tx to finish...\nGetting URIs\nToken 1 URI:  ipfs://metadata/1.json\nToken totalTokens URI:  ipfs://metadata/5.json\n')),(0,o.kt)("p",null,"This concludes our work on the ",(0,o.kt)("inlineCode",{parentName:"p"},"SimpleMultiAsset.sol"),". We can now move on to examining the ",(0,o.kt)("inlineCode",{parentName:"p"},"AdvancedMultiAsset.sol"),"."),(0,o.kt)("h2",{id:"advancedmultiasset"},"AdvancedMultiAsset"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"AdvancedMultiAsset")," smart contract allows for more flexibility when using the multi asset lego. It implements minimum required implementation in order to be compatible with RMRK multi asset, but leaves more business logic implementation freedom to the developer. It uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"RMRKMultiAsset.sol")," import to gain access to the Multi asset lego:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'import "@rmrk-team/evm-contracts/contracts/RMRK/multiasset/RMRKMultiAsset.sol";\n')),(0,o.kt)("p",null,"We only need ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"symbol")," of the NFT in order to properly initialize it after the ",(0,o.kt)("inlineCode",{parentName:"p"},"AdvancedMultiAsset")," inherits it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"contract AdvancedMultiAsset is RMRKMultiAsset {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        string memory name,\n        string memory symbol\n    )\n        RMRKMultiAsset(name, symbol)\n    {\n        // Custom optional: constructor logic\n    }\n}\n")),(0,o.kt)("p",null,"This is all that is required to get you started with implementing the Multi asset RMRK lego."),(0,o.kt)("p",null,"The full code is thus:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.16;\n\nimport "@rmrk-team/evm-contracts/contracts/RMRK/multiasset/RMRKMultiAsset.sol";\n\ncontract AdvancedMultiAsset is RMRKMultiAsset {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        string memory name,\n        string memory symbol\n    )\n        RMRKMultiAsset(name, symbol)\n    {\n        // Custom optional: constructor logic\n    }\n}\n')),(0,o.kt)("p",null,"Using ",(0,o.kt)("inlineCode",{parentName:"p"},"RMRKMultiAsset")," requires custom implementation of minting logic. Available internal functions to use when writing it are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_mint(address to, uint256 tokenId)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_safeMint(address to, uint256 tokenId)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_safeMint(address to, uint256 tokenId, bytes memory data)"))),(0,o.kt)("p",null,"In addition to the minting functions, you should also implement the burning, transfer and asset management functions if they apply to your use case:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_burn(uint256 tokenId)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_addAssetEntry(uint64 id, string memory metadataURI)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_addAssetToToken(uint256 tokenId, uint64 assetId, uint64 replacesAssetWithId)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"transferFrom(address from, address to, uint256 tokenId)"))),(0,o.kt)("p",null,"Any additional functions supporting your NFT use case and utility can also be added."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"training-data"},"Training Data"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'## Deploy Script\n\nThe deploy script for the `SimpleMultiAsset` smart contract resides in `deployMultiAsset.ts`.\n\nThe script uses `ethers`, `SimpleMultiAsset` and `ContractTransaction` imports. The empty deploy script should look like this:\n\n```\nimport { ethers } from "hardhat";\nimport { SimpleMultiAsset } from "../typechain-types";\nimport { ContractTransaction } from "ethers";\n\nasync function main() {\n\n}\n\nmain().catch((error) => {\nconsole.error(error);\nprocess.exitCode = 1;\n});\n```\n\nBefore we can deploy the parent and child smart contracts, we should prepare the constants that we will use in the script:\n\n```\nconst pricePerMint = ethers.utils.parseEther("0.0001");\nconst totalTokens = 5;\nconst [owner] = await ethers.getSigners();\n```\n\nNow that the constants are ready, we can deploy the smart contract and log the address of the contract to the console:\n\n```\nconst contractFactory = await ethers.getContractFactory(\n    "SimpleMultiAsset"\n);\nconst token: SimpleMultiAsset = await contractFactory.deploy(\n    {\n    erc20TokenAddress: ethers.constants.AddressZero,\n    tokenUriIsEnumerable: true,\n    royaltyRecipient: ethers.constants.AddressZero,\n    royaltyPercentageBps: 0,\n    maxSupply: 1000,\n    pricePerMint: pricePerMint \n    }\n);\n\nawait token.deployed();\nconsole.log(`Sample contract deployed to ${token.address}`);\n```\n\nA custom script added to `package.json` allows us to easily run the script:\n\n```\n"scripts": {\n    "deploy-multi-asset": "hardhat run scripts/deployMultiAsset.ts"\n}\n```\n\nUsing the script with `npm run deploy-multi-asset` should return the following output:\n\n```\nnpm run deploy-multi-asset\n\n> @rmrk-team/evm-contract-samples@0.1.0 deploy-multi-asset\n> hardhat run scripts/deployMultiAsset.ts\n\nCompiled 47 Solidity files successfully\nSample contract deployed to 0x5FbDB2315678afecb367f032d93F642f64180aa3\n```\n\n## User Journey\n\nWith the deploy script ready, we can examine how the journey of a user using multi asset would look like using this smart contract.\nThe base of it is the same as the deploy script, as we need to deploy the smart contract in order to interact with it:\n\n```\nimport { ethers } from "hardhat";\nimport { SimpleMultiAsset } from "../typechain-types";\nimport { ContractTransaction } from "ethers";\n\nasync function main() {\nconst pricePerMint = ethers.utils.parseEther("0.0001");\nconst totalTokens = 5;\nconst [ , tokenOwner] = await ethers.getSigners();\n\nconst contractFactory = await ethers.getContractFactory(\n    "SimpleMultiAsset"\n);\nconst token: SimpleMultiAsset = await contractFactory.deploy(\n    {\n    erc20TokenAddress: ethers.constants.AddressZero,\n    tokenUriIsEnumerable: true,\n    royaltyRecipient: ethers.constants.AddressZero,\n    royaltyPercentageBps: 0,\n    maxSupply: 1000,\n    pricePerMint: pricePerMint \n    }\n);\n\nawait token.deployed();\nconsole.log(`Sample contract deployed to ${token.address}`);\n}\n\nmain().catch((error) => {\nconsole.error(error);\nprocess.exitCode = 1;\n});\n```\n\nNOTE: We assign the `tokenOwner` the second available signer, so that the assets are not automatically accepted when added to the token. This happens when an account adding an asset to a token is also the owner of said token.\n\nFirst thing that needs to be done after the smart contract is deployed it to mint the NFT. We will use the `totalTokens` constant to specify how many tokens to mint:\n\n```\nconsole.log("Minting tokens");\nlet tx = await token.mint(tokenOwner.address, totalTokens, {\n    value: pricePerMint.mul(totalTokens),\n});\nawait tx.wait();\nconsole.log(`Minted ${totalTokens} tokens`);\nconst totalSupply = await token.totalSupply();\nconsole.log("Total tokens: %s", totalSupply);\n```\n\nNow that the tokens are minted, we can add new assets to the smart contract. We will prepare a batch of transactions that will add simple IPFS metadata link for the assets in the smart contract. Once the transactions are ready, we will send them and get all of the assets to output to the console:\n\n```\nconsole.log("Adding assets");\nlet allTx: ContractTransaction[] = [];\nfor (let i = 1; i <= totalTokens; i++) {\n    let tx = await token.addAssetEntry(`ipfs://metadata/${i}.json`);\n    allTx.push(tx);\n}\nconsole.log(`Added ${totalTokens} assets`);\n\nconsole.log("Awaiting for all tx to finish...");\nawait Promise.all(allTx.map((tx) => tx.wait()));\n```\n\nOnce the assets are added to the smart contract we can assign each asset to one of the tokens:\n\n```\nconsole.log("Adding assets to tokens");\nallTx = [];\nfor (let i = 1; i <= totalTokens; i++) {\n    // We give each token a asset id with the same number. This is just a coincidence, not a restriction.\n    let tx = await token.addAssetToToken(i, i, 0);\n    allTx.push(tx);\n    console.log(`Added asset ${i} to token ${i}.`);\n}\nconsole.log("Awaiting for all tx to finish...");\nawait Promise.all(allTx.map((tx) => tx.wait()));\n```\n\nAfter the assets are added to the NFTs, we have to accept them. We will do this by once again building a batch of transactions for each of the tokens and send them at the end:\n\n```\nconsole.log("Accepting token assets");\nallTx = [];\nfor (let i = 1; i <= totalTokens; i++) {\n    // Accept pending asset for each token (on index 0)\n    let tx = await token.connect(tokenOwner).acceptAsset(i, 0, i);\n    allTx.push(tx);\n    console.log(`Accepted first pending asset for token ${i}.`);\n}\nconsole.log("Awaiting for all tx to finish...");\nawait Promise.all(allTx.map((tx) => tx.wait()));\n```\n\nNOTE: Accepting assets is done in a array that gets elements, new assets, appended to the end of it. Once the asset is accepted, the asset that was added last, takes its place. For example:\n\n- We have assets A, B, C and D in the pending array organised like this: [A, B, C, D].\n- Accepting the asset A updates the array to look like this: [D, B, C].\n- Accepting the asset B updates the array to look like this: [A, D, C].\n\nFinally we can check wether the URI are assigned as expected and output the values to the console:\n\n```\nconsole.log("Getting URIs");\nconst uriToken1 = await token.tokenURI(1);\nconst uriFinalToken = await token.tokenURI(totalTokens);\n\nconsole.log("Token 1 URI: ", uriToken1);\nconsole.log("Token totalTokens URI: ", uriFinalToken);\n```\n\nWith the user journey script concluded, we can add a custom helper to the `package.json` to make running it easier:\n\n```\n    "user-journey-multi-asset": "hardhat run scripts/multiAssetUserJourney.ts"\n```\n\nRunning it using `npm run user-journey-multi-asset` should return the following output:\n\n```\nnpm run user-journey-multi-asset\n\n> @rmrk-team/evm-contract-samples@0.1.0 user-journey-multi-asset\n> hardhat run scripts/multiAssetUserJourney.ts\n\nSample contract deployed to 0x5FbDB2315678afecb367f032d93F642f64180aa3\nMinting tokens\nMinted 5 tokens\nTotal tokens: 5\nAdding assets\nAdded 5 assets\nAwaiting for all tx to finish...\nAll assets: [\nBigNumber { value: "1" },\nBigNumber { value: "2" },\nBigNumber { value: "3" },\nBigNumber { value: "4" },\nBigNumber { value: "5" }\n]\nAdding assets to tokens\nAdded asset 1 to token 1.\nAdded asset 2 to token 2.\nAdded asset 3 to token 3.\nAdded asset 4 to token 4.\nAdded asset 5 to token 5.\nAwaiting for all tx to finish...\nAccepting token assets\nAccepted first pending asset for token 1.\nAccepted first pending asset for token 2.\nAccepted first pending asset for token 3.\nAccepted first pending asset for token 4.\nAccepted first pending asset for token 5.\nAwaiting for all tx to finish...\nGetting URIs\nToken 1 URI:  ipfs://metadata/1.json\nToken totalTokens URI:  ipfs://metadata/5.json\n```\n\nThis concludes our work on the `SimpleMultiAsset.sol`. We can now move on to examining the `AdvancedMultiAsset.sol`.\n\n## AdvancedMultiAsset\n\nThe `AdvancedMultiAsset` smart contract allows for more flexibility when using the multi asset lego. It implements minimum required implementation in order to be compatible with RMRK multi asset, but leaves more business logic implementation freedom to the developer. It uses the `RMRKMultiAsset.sol` import to gain access to the Multi asset lego:\n\n```\nimport "@rmrk-team/evm-contracts/contracts/RMRK/multiasset/RMRKMultiAsset.sol";\n```\n\nWe only need `name` and `symbol` of the NFT in order to properly initialize it after the `AdvancedMultiAsset` inherits it:\n\n```\ncontract AdvancedMultiAsset is RMRKMultiAsset {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        string memory name,\n        string memory symbol\n    )\n        RMRKMultiAsset(name, symbol)\n    {\n        // Custom optional: constructor logic\n    }\n}\n```\n\nThis is all that is required to get you started with implementing the Multi asset RMRK lego.\n\nThe full code is thus:\n\n```\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.16;\n\nimport "@rmrk-team/evm-contracts/contracts/RMRK/multiasset/RMRKMultiAsset.sol";\n\ncontract AdvancedMultiAsset is RMRKMultiAsset {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        string memory name,\n        string memory symbol\n    )\n        RMRKMultiAsset(name, symbol)\n    {\n        // Custom optional: constructor logic\n    }\n}\n```\n\nUsing `RMRKMultiAsset` requires custom implementation of minting logic. Available internal functions to use when writing it are:\n\n- `_mint(address to, uint256 tokenId)`\n- `_safeMint(address to, uint256 tokenId)`\n- `_safeMint(address to, uint256 tokenId, bytes memory data)`\n\nIn addition to the minting functions, you should also implement the burning, transfer and asset management functions if they apply to your use case:\n\n- `_burn(uint256 tokenId)`\n- `_addAssetEntry(uint64 id, string memory metadataURI)`\n- `_addAssetToToken(uint256 tokenId, uint64 assetId, uint64 replacesAssetWithId)`\n- `transferFrom(address from, address to, uint256 tokenId)`\n\nAny additional functions supporting your NFT use case and utility can also be added.\n')))}p.isMDXComponent=!0}}]);