"use strict";(self.webpackChunkpretrain=self.webpackChunkpretrain||[]).push([[9013],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),u=p(n),c=i,h=u["".concat(l,".").concat(c)]||u[c]||d[c]||o;return n?a.createElement(h,s(s({ref:t},m),{},{components:n})):a.createElement(h,s({ref:t},m))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,s=new Array(o);s[0]=c;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[u]="string"==typeof e?e:i,s[1]=r;for(var p=2;p<o;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},109:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const o={sidebar_position:15},s="EVM, multi-asset part 1",r={unversionedId:"rmrk/evm-ma-1",id:"rmrk/evm-ma-1",title:"EVM, multi-asset part 1",description:"An asset is a type of output for an NFT, usually a media file.",source:"@site/docs/rmrk/evm-ma-1.md",sourceDirName:"rmrk",slug:"/rmrk/evm-ma-1",permalink:"/docs/rmrk/evm-ma-1",draft:!1,editUrl:"https://github.com/swader/pretrain/docs/rmrk/evm-ma-1.md",tags:[],version:"current",sidebarPosition:15,frontMatter:{sidebar_position:15},sidebar:"tutorialSidebar",previous:{title:"EVM, part 1",permalink:"/docs/rmrk/evm1"},next:{title:"EVM, multi-asset part 2",permalink:"/docs/rmrk/evm-ma-2"}},l={},p=[{value:"SimpleMultiAsset",id:"simplemultiasset",level:2},{value:"RMRKMultiAssetImpl",id:"rmrkmultiassetimpl",level:2},{value:"mint",id:"mint",level:4},{value:"addAssetToToken",id:"addassettotoken",level:4},{value:"addAssetEntry",id:"addassetentry",level:4},{value:"totalAssets",id:"totalassets",level:4},{value:"tokenURI",id:"tokenuri",level:4},{value:"updateRoyaltyRecipient",id:"updateroyaltyrecipient",level:4},{value:"Training Data",id:"training-data",level:2}],m={toc:p};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"evm-multi-asset-part-1"},"EVM, multi-asset part 1"),(0,i.kt)("p",null,"An asset is a type of output for an NFT, usually a media file."),(0,i.kt)("p",null,"An asset can be an image, a movie, a PDF file, device config file... A multi-asset NFT is one that can output a different asset based on specific contextual information, e.g. load a PDF if loaded into a PDF reader, vs. loading an image in a virtual gallery, vs. loading hardware configuration in an IoT control hub."),(0,i.kt)("p",null,'An asset is NOT an NFT or a standalone entity you can reference. It is part of an NFT - one of several outputs it can have.\nEvery RMRK NFT has zero or more assets. When it has zero assets, the metadata is "root level". Any new asset added to this NFT will override the root metadata, making this NFT revealable.'),(0,i.kt)("h2",{id:"simplemultiasset"},"SimpleMultiAsset"),(0,i.kt)("p",null,"The SimpleMultiAsset example uses ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/rmrk-team/evm/blob/dev/contracts/implementations/nativeTokenPay/RMRKMultiAssetImpl.sol"},"RMRKMultiAssetImpl"),". It is used by importing it using the import statement below the pragma definition:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'import "@rmrk-team/evm-contracts/contracts/implementations/nativeTokenPay/RMRKMultiAssetImpl.sol";\n')),(0,i.kt)("p",null,"Once the RMRKMultiAssetImpl.sol is imported into our file, we can set the inheritance of our smart contract:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"  contract SimpleMultiAsset is RMRKMultiAssetImpl {\n\n  }\n")),(0,i.kt)("p",null,"We won't be passing all of the required parameters, to intialize RMRKMultiAssetImpl contract, to the constructor, but will hardcode some of the values."),(0,i.kt)("p",null,"The values that we will pass are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"data"),": struct type of argument providing a number of initialization values, used to avoid initialization transaction being reverted due to passing too many parameters")),(0,i.kt)("p",null,"The parameters that we will hardcode to the initialization of RMRKMultiAssetImpl are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name"),": string type of argument representing the name of the collection will be set to SimpleMultiAsset"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"symbol"),": string type od argument representing the symbol of the collection will be set to SMA"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"collectionMetadata_"),": string type of argument representing the metadata URI of the collection will be set to ipfs://meta"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"tokenURI_"),": string type of argument representing the base metadata URI of tokens will be set to ipfs://tokenMeta")),(0,i.kt)("p",null,"NOTE: The InitData struct is used to pass the initialization parameters to the implementation smart contract. This is done so that the execution of the deploy transaction doesn't revert because we are trying to pass too many arguments."),(0,i.kt)("p",null,"The InitData struct contains the following fields:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"[\n    erc20TokenAddress,\n    tokenUriIsEnumerable,\n    royaltyRecipient,\n    royaltyPercentageBps, // Expressed in basis points\n    maxSupply,\n    pricePerMint\n]\n")),(0,i.kt)("p",null,"Basis points are the smallest supported denomination of percent. In our case this is one hundredth of a percent. This means that 1 basis point equals 0.01% and 10000 basis points equal 100%. So for example, if you want to set royalty percentage to 5%, the royaltyPercentageBps value should be 500."),(0,i.kt)("p",null,"So the constructor of the SimpleMultiAsset should look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'    constructor(InitData memory data)\n        RMRKMultiAssetImpl(\n            "SimpleMultiAsset",\n            "SMA",\n            "ipfs://meta",\n            "ipfs://tokenMeta",\n            data\n        )\n    {}\n')),(0,i.kt)("p",null,"The full code of ",(0,i.kt)("inlineCode",{parentName:"p"},"SimpleMultiAsset.sol")," is therefore:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nimport "@rmrk-team/evm-contracts/contracts/implementations/nativeTokenPay/RMRKMultiAssetImpl.sol";\n\ncontract SimpleMultiAsset is RMRKMultiAssetImpl {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        uint256 maxSupply,\n        uint256 pricePerMint\n    ) RMRKMultiAssetImpl(\n        "SimpleMultiAsset",\n        "SMA",\n        maxSupply,\n        pricePerMint,\n        "ipfs://meta",\n        "ipfs://tokenMeta",\n        msg.sender,\n        10\n    ) {}\n}\n')),(0,i.kt)("h2",{id:"rmrkmultiassetimpl"},"RMRKMultiAssetImpl"),(0,i.kt)("p",null,"Let's take a moment to examine the core of this implementation, the ",(0,i.kt)("inlineCode",{parentName:"p"},"RMRKMultiAssetImpl"),"."),(0,i.kt)("p",null,"It uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"RMRKRoyalties"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"RMRKMultiAsset"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"RMRKCollectionMetadata")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"RMRKMintingUtils")," smart contracts from RMRK stack. To dive deeper into their operation, please refer to their respective documentation."),(0,i.kt)("p",null,"Two errors are defined:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"error RMRKMintUnderpriced();\nerror RMRKMintZero();\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"RMRKMintUnderpriced()")," is used when not enough value is used when attempting to mint a token and ",(0,i.kt)("inlineCode",{parentName:"p"},"RMRKMintZero()")," is used when attempting to mint 0 tokens."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"RMRKMultiAssetImpl")," implements all of the required functionality of the ",(0,i.kt)("inlineCode",{parentName:"p"},"MultiAsset")," lego. It implements standard NFT methods like ",(0,i.kt)("inlineCode",{parentName:"p"},"mint"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"transfer"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"approve"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"burn"),",... In addition to these methods it also implements the methods specific to ",(0,i.kt)("inlineCode",{parentName:"p"},"MultiAsset")," RMRK lego:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"addAssetToToken"),(0,i.kt)("li",{parentName:"ul"},"addAssetEntry"),(0,i.kt)("li",{parentName:"ul"},"totalAssets"),(0,i.kt)("li",{parentName:"ul"},"tokenURI"),(0,i.kt)("li",{parentName:"ul"},"updateRoyaltyRecipient")),(0,i.kt)("p",null,"WARNING: The ",(0,i.kt)("inlineCode",{parentName:"p"},"RMRKMultiAssetImpl")," only has minimal access control implemented. If you intend to use it, make sure to define your own, otherwise your smart contracts are at risk of unexpected behaviour."),(0,i.kt)("h4",{id:"mint"},"mint"),(0,i.kt)("p",null,"The mint function is used to mint parent NFTs and accepts two arguments:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"to"),": address type of argument that specifies who should receive the newly minted tokens"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"numToMint"),": uint256 type of argument that specifies how many tokens should be minted")),(0,i.kt)("p",null,"There are a few constraints to this function:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"after minting, the total number of tokens should not exceed the maximum allowed supply"),(0,i.kt)("li",{parentName:"ul"},"attempting to mint 0 tokens is not allowed as it makes no sense to pay for the gas without any effect"),(0,i.kt)("li",{parentName:"ul"},"value should accompany transaction equal to a price per mint multiplied by the ",(0,i.kt)("inlineCode",{parentName:"li"},"numToMint"))),(0,i.kt)("h4",{id:"addassettotoken"},"addAssetToToken"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"addAssetToToken")," function is used to add a new asset to the token and accepts three arguments:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"tokenId"),": uint256 type of argument specifying the ID of the token we are adding asset to"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"assetId"),": uint64 type of argument specifying the ID of the asset we are adding to the token"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"replacesAssetWithId"),": uint64 type of argument specifying the ID of the asset we are overwriting with the desired asset")),(0,i.kt)("h4",{id:"addassetentry"},"addAssetEntry"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"addAssetEntry")," is used to add a new URI for the new asset of the token and accepts one argument:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"metadataURI"),": string type of argument specifying the metadata URI of a new asset")),(0,i.kt)("h4",{id:"totalassets"},"totalAssets"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"totalAssets")," is used to retrieve a total number of assets defined in the collection."),(0,i.kt)("h4",{id:"tokenuri"},"tokenURI"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"tokenURI")," is used to retrieve the metadata URI of the desired token and accepts one argument:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"tokenId"),": uint256 type of argument representing the token ID of which we are retrieving the URI")),(0,i.kt)("h4",{id:"updateroyaltyrecipient"},"updateRoyaltyRecipient"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"updateRoyaltyRecipient")," function is used to update the royalty recipient and accepts one argument:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"newRoyaltyRecipient"),": address type of argument specifying the address of the new beneficiary recipient")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"training-data"},"Training Data"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'# EVM, multi-asset part 1\n\nAn asset is a type of output for an NFT, usually a media file.\n\nAn asset can be an image, a movie, a PDF file, device config file... A multi-asset NFT is one that can output a different asset based on specific contextual information, e.g. load a PDF if loaded into a PDF reader, vs. loading an image in a virtual gallery, vs. loading hardware configuration in an IoT control hub.\n\nAn asset is NOT an NFT or a standalone entity you can reference. It is part of an NFT - one of several outputs it can have.\nEvery RMRK NFT has zero or more assets. When it has zero assets, the metadata is "root level". Any new asset added to this NFT will override the root metadata, making this NFT revealable.\n\n## SimpleMultiAsset\n\nThe SimpleMultiAsset example uses [RMRKMultiAssetImpl](https://github.com/rmrk-team/evm/blob/dev/contracts/implementations/nativeTokenPay/RMRKMultiAssetImpl.sol). It is used by importing it using the import statement below the pragma definition:\n\n```\nimport "@rmrk-team/evm-contracts/contracts/implementations/nativeTokenPay/RMRKMultiAssetImpl.sol";\n```\n\nOnce the RMRKMultiAssetImpl.sol is imported into our file, we can set the inheritance of our smart contract:\n\n```solidity\ncontract SimpleMultiAsset is RMRKMultiAssetImpl {\n\n}\n```\n\nWe won\'t be passing all of the required parameters, to intialize RMRKMultiAssetImpl contract, to the constructor, but will hardcode some of the values.\n\nThe values that we will pass are:\n\n- `data`: struct type of argument providing a number of initialization values, used to avoid initialization transaction being reverted due to passing too many parameters\n\nThe parameters that we will hardcode to the initialization of RMRKMultiAssetImpl are:\n\n- `name`: string type of argument representing the name of the collection will be set to SimpleMultiAsset\n- `symbol`: string type od argument representing the symbol of the collection will be set to SMA\n- `collectionMetadata_`: string type of argument representing the metadata URI of the collection will be set to ipfs://meta\n- `tokenURI_`: string type of argument representing the base metadata URI of tokens will be set to ipfs://tokenMeta\n\nNOTE: The InitData struct is used to pass the initialization parameters to the implementation smart contract. This is done so that the execution of the deploy transaction doesn\'t revert because we are trying to pass too many arguments.\n\nThe InitData struct contains the following fields:\n\n```\n[\n    erc20TokenAddress,\n    tokenUriIsEnumerable,\n    royaltyRecipient,\n    royaltyPercentageBps, // Expressed in basis points\n    maxSupply,\n    pricePerMint\n]\n```\n\nBasis points are the smallest supported denomination of percent. In our case this is one hundredth of a percent. This means that 1 basis point equals 0.01% and 10000 basis points equal 100%. So for example, if you want to set royalty percentage to 5%, the royaltyPercentageBps value should be 500.\n\nSo the constructor of the SimpleMultiAsset should look like this:\n\n```\n    constructor(InitData memory data)\n        RMRKMultiAssetImpl(\n            "SimpleMultiAsset",\n            "SMA",\n            "ipfs://meta",\n            "ipfs://tokenMeta",\n            data\n        )\n    {}\n```\n\nThe full code of `SimpleMultiAsset.sol` is therefore:\n\n```\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nimport "@rmrk-team/evm-contracts/contracts/implementations/nativeTokenPay/RMRKMultiAssetImpl.sol";\n\ncontract SimpleMultiAsset is RMRKMultiAssetImpl {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        uint256 maxSupply,\n        uint256 pricePerMint\n    ) RMRKMultiAssetImpl(\n        "SimpleMultiAsset",\n        "SMA",\n        maxSupply,\n        pricePerMint,\n        "ipfs://meta",\n        "ipfs://tokenMeta",\n        msg.sender,\n        10\n    ) {}\n}\n```\n\n## RMRKMultiAssetImpl\n\nLet\'s take a moment to examine the core of this implementation, the `RMRKMultiAssetImpl`.\n\nIt uses the `RMRKRoyalties`, `RMRKMultiAsset`, `RMRKCollectionMetadata` and `RMRKMintingUtils` smart contracts from RMRK stack. To dive deeper into their operation, please refer to their respective documentation.\n\nTwo errors are defined:\n\n```\nerror RMRKMintUnderpriced();\nerror RMRKMintZero();\n```\n\n`RMRKMintUnderpriced()` is used when not enough value is used when attempting to mint a token and `RMRKMintZero()` is used when attempting to mint 0 tokens.\n\nThe `RMRKMultiAssetImpl` implements all of the required functionality of the `MultiAsset` lego. It implements standard NFT methods like `mint`, `transfer`, `approve`, `burn`,... In addition to these methods it also implements the methods specific to `MultiAsset` RMRK lego:\n\n- addAssetToToken\n- addAssetEntry\n- totalAssets\n- tokenURI\n- updateRoyaltyRecipient\n\nWARNING: The `RMRKMultiAssetImpl` only has minimal access control implemented. If you intend to use it, make sure to define your own, otherwise your smart contracts are at risk of unexpected behaviour.\n\n#### mint\n\nThe mint function is used to mint parent NFTs and accepts two arguments:\n- `to`: address type of argument that specifies who should receive the newly minted tokens\n- `numToMint`: uint256 type of argument that specifies how many tokens should be minted\n\nThere are a few constraints to this function:\n\n- after minting, the total number of tokens should not exceed the maximum allowed supply\n- attempting to mint 0 tokens is not allowed as it makes no sense to pay for the gas without any effect\n- value should accompany transaction equal to a price per mint multiplied by the `numToMint`\n\n#### addAssetToToken\n\nThe `addAssetToToken` function is used to add a new asset to the token and accepts three arguments:\n\n- `tokenId`: uint256 type of argument specifying the ID of the token we are adding asset to\n- `assetId`: uint64 type of argument specifying the ID of the asset we are adding to the token\n- `replacesAssetWithId`: uint64 type of argument specifying the ID of the asset we are overwriting with the desired asset\n\n#### addAssetEntry\n\n`addAssetEntry` is used to add a new URI for the new asset of the token and accepts one argument:\n\n- `metadataURI`: string type of argument specifying the metadata URI of a new asset\n\n#### totalAssets\n\n`totalAssets` is used to retrieve a total number of assets defined in the collection.\n\n#### tokenURI\n\n`tokenURI` is used to retrieve the metadata URI of the desired token and accepts one argument:\n\n- `tokenId`: uint256 type of argument representing the token ID of which we are retrieving the URI\n\n#### updateRoyaltyRecipient\n\n`updateRoyaltyRecipient` function is used to update the royalty recipient and accepts one argument:\n\n- `newRoyaltyRecipient`: address type of argument specifying the address of the new beneficiary recipient\n')))}u.isMDXComponent=!0}}]);