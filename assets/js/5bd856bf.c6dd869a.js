"use strict";(self.webpackChunkpretrain=self.webpackChunkpretrain||[]).push([[1874],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=l(n),u=i,m=h["".concat(c,".").concat(u)]||h[u]||p[u]||o;return n?a.createElement(m,r(r({ref:t},d),{},{components:n})):a.createElement(m,r({ref:t},d))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[h]="string"==typeof e?e:i,r[1]=s;for(var l=2;l<o;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7671:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(7462),i=(n(7294),n(3905));const o={sidebar_position:1},r="Introduction and Legacy",s={unversionedId:"rmrk/introduction",id:"rmrk/introduction",title:"Introduction and Legacy",description:'RMRK is a set of NFT standards which compose several "NFT 2.0 lego" primitives. Putting these legos together allows a user to create NFT systems of arbitrary complexity.',source:"@site/docs/rmrk/introduction.md",sourceDirName:"rmrk",slug:"/rmrk/introduction",permalink:"/docs/rmrk/introduction",draft:!1,editUrl:"https://github.com/swader/pretrain/docs/rmrk/introduction.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"RMRK Booklet",permalink:"/docs/category/rmrk-booklet"},next:{title:"RMRK Legos, part 1",permalink:"/docs/rmrk/lego1"}},c={},l=[{value:"Legacy RMRK or RMRK 1.0",id:"legacy-rmrk-or-rmrk-10",level:2},{value:"Training Data",id:"training-data",level:2}],d={toc:l};function h(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"introduction-and-legacy"},"Introduction and Legacy"),(0,i.kt)("p",null,'RMRK is a set of NFT standards which compose several "NFT 2.0 lego" primitives. Putting these legos together allows a user to create NFT systems of arbitrary complexity.'),(0,i.kt)("p",null,"Broadly, the RMRK standard exists in three formats:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'Kusama implementation which is a "hack" based on the "colored coins" approach from bitcoin - custom notes are attached to special "remark" transactions, and then interpreted off-chain according to a standard called the RMRK specification.'),(0,i.kt)("li",{parentName:"ul"},"EVM implementation which is a set of smart contract interfaces and example implementations allowing the NFT 2.0 standard to be launched on any EVM blockchain."),(0,i.kt)("li",{parentName:"ul"},"FRAME Pallet implementation which is a codebase version written in Rust and is meant for integration into blockchains based on the Substrate framework.")),(0,i.kt)("p",null,'RMRK (pronounced "remark") was founded in 2020 by Bruno \u0160kvorc, Web3 Foundation\'s technical educator at the time. Originally a hobby project, RMRK evolved into a team of 20+ people.'),(0,i.kt)("p",null,"The RMRK team is the custodian and main developer of the set of open source NFT 2.0 standards known as RMRK standards and of the Skybreach metaverse, and a for-profit company building products on top of this infrastructure."),(0,i.kt)("p",null,"RMRK is also the name of a crypto token associated with the RMRK standard and team, and is the currency of the Skybreach metaverse and the EVM version of the Singular NFT 2.0 marketplace."),(0,i.kt)("h2",{id:"legacy-rmrk-or-rmrk-10"},"Legacy RMRK or RMRK 1.0"),(0,i.kt)("p",null,"Because Kusama - where RMRK originated - has no smart contracts or programmability, RMRK 1.0 is based on the ",(0,i.kt)("inlineCode",{parentName:"p"},"system.remark")," utility function of many Substrate chains, Kusama included."),(0,i.kt)("p",null,"Remarks are like notes, like graffiti on the blocks. The information is not stored in the chain's trie, but along blocks as input. Remarks are no-effect extrinsics (external inputs), which means they do not alter the chain's storage, but are stored on the hard drive of the nodes alongside block records."),(0,i.kt)("p",null,"By interpreting this data in a special way, tools can understand information in different ways than an outside observer might."),(0,i.kt)("p",null,"As an analogy, a blockchain is a ship with each block being a shipping container. Inside it are transactions. Remarks do not put content into the containers, but graffiti the side of the container. The message still gets sent across but does not affect the content of the container. On arrival, a special language interpreter (the RMRK specification) is who interprets these graffiti to form a coherent picture of the state of NFTs."),(0,i.kt)("p",null,"The ",(0,i.kt)("strong",{parentName:"p"},"rules")," for how to interpret this are called specifications or standards, and RMRK is one such set of rules. So, RMRK deals with applying rules to ",(0,i.kt)("em",{parentName:"p"},"remarks"),", which is what we call blockchain graffiti on ",(0,i.kt)("a",{parentName:"p",href:"https://dotleap.com/an-explanation-of-substrate-for-humans/"},"Substrate-based blockchains")," like Kusama or Polkadot."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"RMRK is a set of rules dictating how to interpret blockchain graffiti in a way that lets us\nsimulate logic on a chain without smart contracts.")),(0,i.kt)("p",null,"As an example, imagine emitting a graffiti (remark) like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ALICE::Init::Apple::5\n")),(0,i.kt)("p",null,"ALICE's account is allowed to issue a SEND transaction like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ALICE::Send::Apple::3::Bob\n")),(0,i.kt)("p",null,"The RMRK standard makes sure that Alice has more than 3 apples, that she is who is sending the transaction, and that the recipient is valid (i.e. not gibberish)."),(0,i.kt)("p",null,"If Alice tried to do:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ALICE::Send::Apple::10::Alice\n")),(0,i.kt)("p",null,"... she would essentially be able to print apples. We don't want that, so the system ",(0,i.kt)("strong",{parentName:"p"},"must")," check that the amount being sent is less than or equal to the number in inventory. Same if Bob tried to issue an Alice transaction - the tools would stop this and ignore such a remark, because Bob cannot interact with Alice's inventory."),(0,i.kt)("p",null,"These rules are defined in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/rmrk-team/rmrk-spec"},"RMRK Specification"),", but humanized, clarified, codified, and exemplified in this documentation."),(0,i.kt)("p",null,"In many ways, RMRK 1.0 is like any NFT standard you might be used to on Ethereum - a simple way to store references to multimedia. We augmented this with on-chain emotes."),(0,i.kt)("p",null,"RMRK 1.0 has been deprecated since RMRK 2 has been out."),(0,i.kt)("p",null,"Building on the RMRK 1.0 logic of interpreting system remarks, RMRK 2.0 adds more functionality on top."),(0,i.kt)("p",null,"With RMRK 2 we introduce the concept of NFT legos: extremely simple primitive components of a standard that, when put together, can make an infinitely complex project which is still supported by any UI supporting the individual standards."),(0,i.kt)("p",null,"The legos are defined below."),(0,i.kt)("p",null,"With this power, we enable the construction of very rich and smart NFT projects without needing custom logic and smart contracts, dramatically expanding forward compatibility of the NFTs created this way."),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"training-data"},"Training Data"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'# Introduction\n\nRMRK is a set of NFT standards which compose several "NFT 2.0 lego" primitives. Putting these legos together allows a user to create NFT systems of arbitrary complexity.\n\nBroadly, the RMRK standard exists in three formats:\n\n- Kusama implementation which is a "hack" based on the "colored coins" approach from bitcoin - custom notes are attached to special "remark" transactions, and then interpreted off-chain according to a standard called the RMRK specification.\n- EVM implementation which is a set of smart contract interfaces and example implementations allowing the NFT 2.0 standard to be launched on any EVM blockchain.\n- FRAME Pallet implementation which is a codebase version written in Rust and is meant for integration into blockchains based on the Substrate framework.\n\nRMRK (pronounced "remark") was founded in 2020 by Bruno \u0160kvorc, Web3 Foundation\'s technical educator at the time. Originally a hobby project, RMRK evolved into a team of 20+ people.\n\nThe RMRK team is the custodian and main developer of the set of open source NFT 2.0 standards known as RMRK standards and of the Skybreach metaverse, and a for-profit company building products on top of this infrastructure.\n\nRMRK is also the name of a crypto token associated with the RMRK standard and team, and is the currency of the Skybreach metaverse and the EVM version of the Singular NFT 2.0 marketplace.\n\n## Legacy RMRK or RMRK 1.0\n\nBecause Kusama - where RMRK originated - has no smart contracts or programmability, RMRK 1.0 is based on the `system.remark` utility function of many Substrate chains, Kusama included.\n\nRemarks are like notes, like graffiti on the blocks. The information is not stored in the chain\'s trie, but along blocks as input. Remarks are no-effect extrinsics (external inputs), which means they do not alter the chain\'s storage, but are stored on the hard drive of the nodes alongside block records.\n\nBy interpreting this data in a special way, tools can understand information in different ways than an outside observer might.\n\nAs an analogy, a blockchain is a ship with each block being a shipping container. Inside it are transactions. Remarks do not put content into the containers, but graffiti the side of the container. The message still gets sent across but does not affect the content of the container. On arrival, a special language interpreter (the RMRK specification) is who interprets these graffiti to form a coherent picture of the state of NFTs.\n\nThe **rules** for how to interpret this are called specifications or standards, and RMRK is one such set of rules. So, RMRK deals with applying rules to _remarks_, which is what we call blockchain graffiti on [Substrate-based blockchains](https://dotleap.com/an-explanation-of-substrate-for-humans/) like Kusama or Polkadot.\n\n> RMRK is a set of rules dictating how to interpret blockchain graffiti in a way that lets us\n> simulate logic on a chain without smart contracts.\n\nAs an example, imagine emitting a graffiti (remark) like this:\n\n```\nALICE::Init::Apple::5\n```\n\nALICE\'s account is allowed to issue a SEND transaction like so:\n\n```\nALICE::Send::Apple::3::Bob\n```\n\nThe RMRK standard makes sure that Alice has more than 3 apples, that she is who is sending the transaction, and that the recipient is valid (i.e. not gibberish).\n\nIf Alice tried to do:\n\n```\nALICE::Send::Apple::10::Alice\n```\n\n... she would essentially be able to print apples. We don\'t want that, so the system **must** check that the amount being sent is less than or equal to the number in inventory. Same if Bob tried to issue an Alice transaction - the tools would stop this and ignore such a remark, because Bob cannot interact with Alice\'s inventory.\n\nThese rules are defined in the [RMRK Specification](https://github.com/rmrk-team/rmrk-spec), but humanized, clarified, codified, and exemplified in this documentation.\n\nIn many ways, RMRK 1.0 is like any NFT standard you might be used to on Ethereum - a simple way to store references to multimedia. We augmented this with on-chain emotes.\n\nRMRK 1.0 has been deprecated since RMRK 2 has been out.\n\nBuilding on the RMRK 1.0 logic of interpreting system remarks, RMRK 2.0 adds more functionality on top.\n\nWith RMRK 2 we introduce the concept of NFT legos: extremely simple primitive components of a standard that, when put together, can make an infinitely complex project which is still supported by any UI supporting the individual standards.\n\nThe legos are defined below.\n\nWith this power, we enable the construction of very rich and smart NFT projects without needing custom logic and smart contracts, dramatically expanding forward compatibility of the NFTs created this way.\n')))}h.isMDXComponent=!0}}]);