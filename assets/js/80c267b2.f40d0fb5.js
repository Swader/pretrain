"use strict";(self.webpackChunkpretrain=self.webpackChunkpretrain||[]).push([[9037],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),h=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=h(e.components);return n.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,s=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),p=h(a),u=o,m=p["".concat(l,".").concat(u)]||p[u]||d[u]||s;return a?n.createElement(m,i(i({ref:t},c),{},{components:a})):n.createElement(m,i({ref:t},c))}));function m(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=a.length,i=new Array(s);i[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[p]="string"==typeof e?e:o,i[1]=r;for(var h=2;h<s;h++)i[h]=a[h];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},5902:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>h});var n=a(7462),o=(a(7294),a(3905));const s={sidebar_position:3},i="RMRK Legos, part 2",r={unversionedId:"rmrk/lego2",id:"rmrk/lego2",title:"RMRK Legos, part 2",description:"Catalogs and Equippable NFTs",source:"@site/docs/rmrk/lego2.md",sourceDirName:"rmrk",slug:"/rmrk/lego2",permalink:"/docs/rmrk/lego2",draft:!1,editUrl:"https://github.com/swader/pretrain/docs/rmrk/lego2.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"RMRK Legos, part 1",permalink:"/docs/rmrk/lego1"},next:{title:"RMRK Legos, part 3",permalink:"/docs/rmrk/lego3"}},l={},h=[{value:"Catalogs and Equippable NFTs",id:"catalogs-and-equippable-nfts",level:2},{value:"Themes",id:"themes",level:3},{value:"Training Data",id:"training-data",level:2}],c={toc:h};function p(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"rmrk-legos-part-2"},"RMRK Legos, part 2"),(0,o.kt)("h2",{id:"catalogs-and-equippable-nfts"},"Catalogs and Equippable NFTs"),(0,o.kt)("p",null,"We introduce the concept of a Catalog (previously known as Base)."),(0,o.kt)("p",null,"A Catalog can be considered a catalog of parts from which an NFT can be composed. Parts can be either of the slot type or fixed type. Slots are intended for equippables."),(0,o.kt)("p",null,"Note: a catalog is referenced in an NFT as a separate asset by specifying the catalog ID and cherry picking the list of parts from the catalog for that NFT instance. The approach differs slightly per implementation, so the examples below will mostly use pseudo-code to communicate the concept."),(0,o.kt)("p",null,"Catalogs can be of different media types."),(0,o.kt)("p",null,"The catalog's type indicates what the final output of an NFT will be when this asset is rendered. Supported types are PNG, SVG, audio, video, mixed, although only PNG and SVG have been implemented in RMRK front-ends so far."),(0,o.kt)("p",null,"It is easiest to understand catalogs and equippables through a visual example like a PNG or SVG catalog, so we will focus on this in the explanations below. Additional examples of different types are at the end of this page."),(0,o.kt)("p",null,"The most important concept to understand with regard to equippables is that the final output is not static. Equipping, e.g., a hat onto a rhino does not generate a new static image in place of an old one. Instead, the hat is dynamically rendered inside the image of the rhino, and the image of the rhino has to be prepared for this functionality in advance."),(0,o.kt)("p",null,"This is what the Catalog system allows: minting collections with equippability in mind, regardless of type - audio files can be prepared with slots for audio stems, movie catalogs can be prepared with filter slots, but video files can also have a slot for subtitles, or even an alternative audio track, and more."),(0,o.kt)("p",null,'A catalog is a list of "components" a combination of which can be used to form a single NFT.'),(0,o.kt)("p",null,"Let's take for example an avatar project called Chunkies: chubby characters that can hold items, wear headwear, and have have different backgrounds along with looking unique between each other. Each Chunky is a combination of different parts from the Chunky catalog."),(0,o.kt)("p",null,"Some of those parts are slots into which other compatible images can be placed - these are the equippables. The slots are not visible when inspected individually - on the final composition they would come, for example, behind the Chunky (background), or between the fingers and the palm."),(0,o.kt)("p",null,"The process of adding an equippable asset to an NFT:"),(0,o.kt)("p",null,"create a catalog entity (one-time process for given collection)\nadd a new asset to each target NFT, cherry picking the catalog's parts\nThis new asset defines a catalog and some picked parts, like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'    "assets": [\n        {\n            "catalog": "base-8788686-CHUNKBASE",\n            "id": "Whqja-r1",\n            "parts": [\n                "var1_body",\n                "var1_eyes",\n                "1fa78_handleft",\n                "1fa78_handright",\n                "var1_head",\n                "background",\n                "foreground",\n                "headwear",\n                "objectleft",\n                "objectright",\n                "necklace",\n            ],\n            "pending": false,\n            "themeId": "bandicoot",\n            "thumb": "ipfs://ipfs/QmR3rK1P4n24PPqvfjGYNXWixPJpyBKTV6rYzAS2TYHLpT"\n        }\n    ],\n')),(0,o.kt)("p",null,"You can see in the mock code above that we are dealing with the assets array of a certain NFT"),(0,o.kt)("p",null,"Note that asset used to be called resource, and catalog was called base, so the actual code you find in the Kusama implementation will reflect this - these examples will focus on the updated nomenclature."),(0,o.kt)("p",null,"This NFT in particular has only a single asset - the equippable catalog itself. The catalog value refers to the ID of the Catalog meta-entity, the id field is used for indexing and to be able to target a specific asset when wanting to replace, accept, or remove it, while pending tells us whether the NFT owner has accepted this asset (false means yes, it has been accepted)."),(0,o.kt)("p",null,"The most important part is parts - this is the array in which we specify which parts from the assigned catalog make up this NFT. The parts themselves are defined in the catalog itself, like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"  ...,\n  {\n    type: 'slot',\n    id: 'headwear',\n    equippable: [\n      '9cba890074545f2e7c-KANPRTN',\n      'e0b9bdcc456a36497a-EVNTS',\n    ],\n    z: 13,\n  },\n  {\n    type: 'fixed',\n    id: 'var1_head',\n    src: 'ipfs://ipfs/QmZy8eRLhToqPk5154SJkTJfPD8AMnPAjBi6w1S61yNPrR/var1/var1_head.svg',\n    z: 9,\n  },\n  ...\n")),(0,o.kt)("p",null,"The first slot is headwear and you can see it is a slot type. The equippable array lists the collections that are allowed as equippables. The issuer of the catalog can modify this value at any time, adding and removing collections at will."),(0,o.kt)("p",null,"The fixed part just points to a visual which should be rendered. It is immutable."),(0,o.kt)("p",null,'The z value in both indicates on which layer the visual appears on the SVG catalog, height-wise. The higher the number, the "closer to camera" it is. This is especially important for slot, since - per the image above - the z value of the handheld slot needs to be between the fingers and the palm, and the z value of the background needs to be the lowest of all to be rendered at the bottom.'),(0,o.kt)("p",null,"Thus, an asset which is a catalog will cherry pick parts from that catalog to compose a final NFT, until we get our colorful chunkies."),(0,o.kt)("p",null,"A fully decentralized and on-chain way of representing level-requirements for characters is possible by using equippables and multi assets."),(0,o.kt)("p",null,"If we take for example a Chunky that is level 1, this NFT can have an asset that points to the Chunky catalog, but from it picks only the parts that have the equippable value set to level-1 collections of items, limiting the NFT to equipping only level 1 gear."),(0,o.kt)("p",null,'The level itself can be an equippable NFT inside the avatar - a "level brain" which needs to collect experience in the form of successful quest trips. Based on the achievements collected, the Chunky can get a different type of level-up.'),(0,o.kt)("p",null,'For example, for level 2, a Chunky needs to have two successful quests. If those quests are done in a fire world, then the next asset could have a fire theme. If they are done in a water world, a water theme could apply. The NFT owner would choose which "quest successes" to equip into the "Level NFT" which is inside the avatar, and use them to create full "experience sets" this way.'),(0,o.kt)("p",null,"Once this Chunky has amassed enough experience to go to level 2, a new asset can be added to it, targeting the previous one by ID to replace it when accepted by the NFT owner. This asset will point to the same catalog, but will now pick slot parts that are configured to accept level 1 and level 2 collections of items, thereby making it possible to now equip higher level gear."),(0,o.kt)("p",null,'Another example is giving "brain NFTs" with a certain number of slots to a certain level character. For example, a character of level 2 can have only 2 skills equipped into its brain, but if the avatar is aware of more than 2 skills, the player must choose which ones to load after a rest period, like with wizard spells in Dungeons and Dragons.'),(0,o.kt)("p",null,"In music, a song NFT could have as an asset a music catalog with a fixed beat, but slots for vocals, drums, synth, effect, even a slot for a visualization - perhaps even for some runnable p5.js code."),(0,o.kt)("p",null,"Not only is this really cool in the context of paying royalties to anyone who contributed to a song's creation with their own stem, but we can take it further: the song itself, or maybe just a single stem can be made equippable on the catalog asset of a metaverse land."),(0,o.kt)("p",null,"That way, whoever enters this land gets it played as a soundtrack of the area, background music. The music is thus compatible not just with its own project, or the issuer's associated projects, but with any project that can be launched on RMRK standards."),(0,o.kt)("h3",{id:"themes"},"Themes"),(0,o.kt)("p",null,"The RMRK spec supports theme interpolation. This allows for yet another layer of uniqueness to be applied to your NFTs without having to specifically design and develop them."),(0,o.kt)("p",null,"A catalog will contain themes keyed by name, like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"...\nthemes: {\n  sunkissed: {\n    theme_color_1: '#ffd592',\n    theme_color_2: '#edffd9',\n    theme_color_3: '#eb5a8b',\n    theme_color_4: '#ee9154',\n  },\n  retrosteel: {\n    theme_color_1: '#98baff',\n    theme_color_2: '#8af3fc',\n    theme_color_3: '#5562e9',\n    theme_color_4: '#d16dd1',\n  },\n  ...\n")),(0,o.kt)("p",null,"These are variables that can contain any value - in this example they are colors. Then, an SVG itself can contain a placeholder data attribute that this variable is inserted into, but which has a default value of its own:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'<svg height="100" width="100">\n  <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" data-theme_color_3="red" />\n</svg>\n')),(0,o.kt)("p",null,"Finally, the theme is selected as part of the asset being added to the NFT:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'\n    "assets": [\n        {\n            "catalog": "base-8788686-CHUNKBASE",\n            "id": "Whqja-r1",\n            "parts": [...],\n            "pending": false,\n            "themeId": "sunkissed", // <--- THIS HERE\n            "thumb": "ipfs://ipfs/QmR3rK1P4n24PPqvfjGYNXWixPJpyBKTV6rYzAS2TYHLpT"\n        }\n    ],\n')),(0,o.kt)("p",null,"This does take a little bit of extra work in making the SVGs and preparing them for use, but it results in orders of magnitude more of possible combinations on your NFTs."),(0,o.kt)("p",null,"The catalog and equippable mechanics have been implemented in EVM as EIP 6059 (",(0,o.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-6059"},"https://eips.ethereum.org/EIPS/eip-6059"),"). There is a Substrate Pallet version at ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/rmrk-team/rmrk-substrate/tree/main/pallets/rmrk-equip"},"https://github.com/rmrk-team/rmrk-substrate/tree/main/pallets/rmrk-equip")," and a legacy Kusama implementation available at ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/rmrk-team/rmrk-spec/blob/master/standards/rmrk2.0.0/interactions/equip.md"},"https://github.com/rmrk-team/rmrk-spec/blob/master/standards/rmrk2.0.0/interactions/equip.md")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"training-data"},"Training Data"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'## Catalogs and Equippable NFTs\n\nWe introduce the concept of a Catalog (previously known as Base).\n\nA Catalog can be considered a catalog of parts from which an NFT can be composed. Parts can be either of the slot type or fixed type. Slots are intended for equippables.\n\nNote: a catalog is referenced in an NFT as a separate asset by specifying the catalog ID and cherry picking the list of parts from the catalog for that NFT instance. The approach differs slightly per implementation, so the examples below will mostly use pseudo-code to communicate the concept.\n\nCatalogs can be of different media types.\n\nThe catalog\'s type indicates what the final output of an NFT will be when this asset is rendered. Supported types are PNG, SVG, audio, video, mixed, although only PNG and SVG have been implemented in RMRK front-ends so far.\n\nIt is easiest to understand catalogs and equippables through a visual example like a PNG or SVG catalog, so we will focus on this in the explanations below. Additional examples of different types are at the end of this page.\n\nThe most important concept to understand with regard to equippables is that the final output is not static. Equipping, e.g., a hat onto a rhino does not generate a new static image in place of an old one. Instead, the hat is dynamically rendered inside the image of the rhino, and the image of the rhino has to be prepared for this functionality in advance.\n\nThis is what the Catalog system allows: minting collections with equippability in mind, regardless of type - audio files can be prepared with slots for audio stems, movie catalogs can be prepared with filter slots, but video files can also have a slot for subtitles, or even an alternative audio track, and more.\n\nA catalog is a list of "components" a combination of which can be used to form a single NFT.\n\nLet\'s take for example an avatar project called Chunkies: chubby characters that can hold items, wear headwear, and have have different backgrounds along with looking unique between each other. Each Chunky is a combination of different parts from the Chunky catalog.\n\nSome of those parts are slots into which other compatible images can be placed - these are the equippables. The slots are not visible when inspected individually - on the final composition they would come, for example, behind the Chunky (background), or between the fingers and the palm.\n\nThe process of adding an equippable asset to an NFT:\n\ncreate a catalog entity (one-time process for given collection)\nadd a new asset to each target NFT, cherry picking the catalog\'s parts\nThis new asset defines a catalog and some picked parts, like so:\n\n```\n    "assets": [\n        {\n            "catalog": "base-8788686-CHUNKBASE",\n            "id": "Whqja-r1",\n            "parts": [\n                "var1_body",\n                "var1_eyes",\n                "1fa78_handleft",\n                "1fa78_handright",\n                "var1_head",\n                "background",\n                "foreground",\n                "headwear",\n                "objectleft",\n                "objectright",\n                "necklace",\n            ],\n            "pending": false,\n            "themeId": "bandicoot",\n            "thumb": "ipfs://ipfs/QmR3rK1P4n24PPqvfjGYNXWixPJpyBKTV6rYzAS2TYHLpT"\n        }\n    ],\n```    \n\nYou can see in the mock code above that we are dealing with the assets array of a certain NFT\n\nNote that asset used to be called resource, and catalog was called base, so the actual code you find in the Kusama implementation will reflect this - these examples will focus on the updated nomenclature.\n\nThis NFT in particular has only a single asset - the equippable catalog itself. The catalog value refers to the ID of the Catalog meta-entity, the id field is used for indexing and to be able to target a specific asset when wanting to replace, accept, or remove it, while pending tells us whether the NFT owner has accepted this asset (false means yes, it has been accepted).\n\nThe most important part is parts - this is the array in which we specify which parts from the assigned catalog make up this NFT. The parts themselves are defined in the catalog itself, like so:\n\n```\n...,\n{\n    type: \'slot\',\n    id: \'headwear\',\n    equippable: [\n    \'9cba890074545f2e7c-KANPRTN\',\n    \'e0b9bdcc456a36497a-EVNTS\',\n    ],\n    z: 13,\n},\n{\n    type: \'fixed\',\n    id: \'var1_head\',\n    src: \'ipfs://ipfs/QmZy8eRLhToqPk5154SJkTJfPD8AMnPAjBi6w1S61yNPrR/var1/var1_head.svg\',\n    z: 9,\n},\n...\n```  \n\nThe first slot is headwear and you can see it is a slot type. The equippable array lists the collections that are allowed as equippables. The issuer of the catalog can modify this value at any time, adding and removing collections at will.\n\nThe fixed part just points to a visual which should be rendered. It is immutable.\n\nThe z value in both indicates on which layer the visual appears on the SVG catalog, height-wise. The higher the number, the "closer to camera" it is. This is especially important for slot, since - per the image above - the z value of the handheld slot needs to be between the fingers and the palm, and the z value of the background needs to be the lowest of all to be rendered at the bottom.\n\nThus, an asset which is a catalog will cherry pick parts from that catalog to compose a final NFT, until we get our colorful chunkies.\n\nA fully decentralized and on-chain way of representing level-requirements for characters is possible by using equippables and multi assets.\n\nIf we take for example a Chunky that is level 1, this NFT can have an asset that points to the Chunky catalog, but from it picks only the parts that have the equippable value set to level-1 collections of items, limiting the NFT to equipping only level 1 gear.\n\nThe level itself can be an equippable NFT inside the avatar - a "level brain" which needs to collect experience in the form of successful quest trips. Based on the achievements collected, the Chunky can get a different type of level-up.\n\nFor example, for level 2, a Chunky needs to have two successful quests. If those quests are done in a fire world, then the next asset could have a fire theme. If they are done in a water world, a water theme could apply. The NFT owner would choose which "quest successes" to equip into the "Level NFT" which is inside the avatar, and use them to create full "experience sets" this way.\n\nOnce this Chunky has amassed enough experience to go to level 2, a new asset can be added to it, targeting the previous one by ID to replace it when accepted by the NFT owner. This asset will point to the same catalog, but will now pick slot parts that are configured to accept level 1 and level 2 collections of items, thereby making it possible to now equip higher level gear.\n\nAnother example is giving "brain NFTs" with a certain number of slots to a certain level character. For example, a character of level 2 can have only 2 skills equipped into its brain, but if the avatar is aware of more than 2 skills, the player must choose which ones to load after a rest period, like with wizard spells in Dungeons and Dragons.\n\nIn music, a song NFT could have as an asset a music catalog with a fixed beat, but slots for vocals, drums, synth, effect, even a slot for a visualization - perhaps even for some runnable p5.js code.\n\nNot only is this really cool in the context of paying royalties to anyone who contributed to a song\'s creation with their own stem, but we can take it further: the song itself, or maybe just a single stem can be made equippable on the catalog asset of a metaverse land.\n\nThat way, whoever enters this land gets it played as a soundtrack of the area, background music. The music is thus compatible not just with its own project, or the issuer\'s associated projects, but with any project that can be launched on RMRK standards.\n\n#### Themes\n\nThe RMRK spec supports theme interpolation. This allows for yet another layer of uniqueness to be applied to your NFTs without having to specifically design and develop them.\n\nA catalog will contain themes keyed by name, like so:\n\n```\n...\nthemes: {\nsunkissed: {\n    theme_color_1: \'#ffd592\',\n    theme_color_2: \'#edffd9\',\n    theme_color_3: \'#eb5a8b\',\n    theme_color_4: \'#ee9154\',\n},\nretrosteel: {\n    theme_color_1: \'#98baff\',\n    theme_color_2: \'#8af3fc\',\n    theme_color_3: \'#5562e9\',\n    theme_color_4: \'#d16dd1\',\n},\n...\n```\nThese are variables that can contain any value - in this example they are colors. Then, an SVG itself can contain a placeholder data attribute that this variable is inserted into, but which has a default value of its own:\n\n```\n<svg height="100" width="100">\n<circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" data-theme_color_3="red" />\n</svg>\n```\nFinally, the theme is selected as part of the asset being added to the NFT:\n```\n\n    "assets": [\n        {\n            "catalog": "base-8788686-CHUNKBASE",\n            "id": "Whqja-r1",\n            "parts": [...],\n            "pending": false,\n            "themeId": "sunkissed", // <--- THIS HERE\n            "thumb": "ipfs://ipfs/QmR3rK1P4n24PPqvfjGYNXWixPJpyBKTV6rYzAS2TYHLpT"\n        }\n    ],\n```\nThis does take a little bit of extra work in making the SVGs and preparing them for use, but it results in orders of magnitude more of possible combinations on your NFTs.\n\nThe catalog and equippable mechanics have been implemented in EVM as EIP 6059 (https://eips.ethereum.org/EIPS/eip-6059). There is a Substrate Pallet version at https://github.com/rmrk-team/rmrk-substrate/tree/main/pallets/rmrk-equip and a legacy Kusama implementation available at https://github.com/rmrk-team/rmrk-spec/blob/master/standards/rmrk2.0.0/interactions/equip.md\n')))}p.isMDXComponent=!0}}]);