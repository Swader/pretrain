"use strict";(self.webpackChunkpretrain=self.webpackChunkpretrain||[]).push([[6376],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(n),u=o,h=m["".concat(l,".").concat(u)]||m[u]||d[u]||r;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:o,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2405:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const r={sidebar_position:17},i="EVM, nestable part 1",s={unversionedId:"rmrk/evm-nestable-p1",id:"rmrk/evm-nestable-p1",title:"EVM, nestable part 1",description:"The concept of nested NFTs refers to NFTs being able to own other NFTs.",source:"@site/docs/rmrk/evm-nestable-p1.md",sourceDirName:"rmrk",slug:"/rmrk/evm-nestable-p1",permalink:"/docs/rmrk/evm-nestable-p1",draft:!1,editUrl:"https://github.com/swader/pretrain/docs/rmrk/evm-nestable-p1.md",tags:[],version:"current",sidebarPosition:17,frontMatter:{sidebar_position:17},sidebar:"tutorialSidebar",previous:{title:"EVM, multi-asset part 2",permalink:"/docs/rmrk/evm-ma-2"},next:{title:"EVM, nestable part 2",permalink:"/docs/rmrk/evm-nestable-p2"}},l={},p=[{value:"SimpleNestable",id:"simplenestable",level:2},{value:"RMRKNestableImpl",id:"rmrknestableimpl",level:2},{value:"mint",id:"mint",level:4},{value:"nestMint",id:"nestmint",level:4},{value:"transfer",id:"transfer",level:4},{value:"nestTransfer",id:"nesttransfer",level:4},{value:"tokenURI",id:"tokenuri",level:4},{value:"updateRoyaltyRecipient",id:"updateroyaltyrecipient",level:4},{value:"Deploy Script",id:"deploy-script",level:2},{value:"Training Data",id:"training-data",level:2}],c={toc:p};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"evm-nestable-part-1"},"EVM, nestable part 1"),(0,o.kt)("p",null,"The concept of nested NFTs refers to NFTs being able to own other NFTs."),(0,o.kt)("p",null,"At its core, the principle is simple: the owner of an NFT does not have to be an externally owned account or a smart contract, it can also be a specific NFT."),(0,o.kt)("p",null,"The process of sending an NFT into another is functionally identical to sending it to another user. The process of sending an NFT out of another NFT involves issuing a transaction from the address which owns the parent."),(0,o.kt)("p",null,"Some NFTs can be configured with special conditions for parent-child relationships. For example:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"some parent NFTs will allow the owner of a child NFT to withdraw that child at any time (e.g. virtual land containing an avatar)"),(0,o.kt)("li",{parentName:"ul"},"some parent NFTs will be prohibited from executing certain interactions on a child (e.g. the owner of a house in which someone else's avatar is a guest should not be able to BURN the guest... probably)"),(0,o.kt)("li",{parentName:"ul"},'some parent NFTs will have special withdrawal conditions, like a music NFT that accepts music stems. The stems can be removed by their owners until a certain number of co-composers upvote a stem enough, or until the owner of the parent music track seals and "publishes" it')),(0,o.kt)("p",null,"NOTE: To dig deeper into the Nestable RMRK lego, you can also refer to the ",(0,o.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-6059"},"EIP-6059")," that we published."),(0,o.kt)("h2",{id:"simplenestable"},"SimpleNestable"),(0,o.kt)("p",null,"The SimpleNestable example uses the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/rmrk-team/evm/blob/dev/contracts/implementations/nativeTokenPay/RMRKNestableImpl.sol"},(0,o.kt)("inlineCode",{parentName:"a"},"RMRKNestableImpl")),". It is used by importing it using the import statement below the pragma definition:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'import "@rmrk-team/evm-contracts/contracts/implementations/nativeTokenPay/RMRKNestableImpl.sol";\n')),(0,o.kt)("p",null,"Once the ",(0,o.kt)("inlineCode",{parentName:"p"},"RMRKNestableImpl.sol")," is imported into our file, we can set the inheritance of our smart contract:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"contract SimpleNestable is RMRKNestableImpl {\n\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"RMRKNestableImpl")," implements all of the required functionality of the Nested RMRK lego. It implements minting of parent NFTs as well as child NFTs. Transferring and burning the NFTs is also implemented."),(0,o.kt)("p",null,"WARNING: The ",(0,o.kt)("inlineCode",{parentName:"p"},"RMRKNestableImpl")," only has minimal access control implemented. If you intend to use it, make sure to define your own, otherwise your smart contracts are at risk of unexpected behaviour."),(0,o.kt)("p",null,"The constructor to initialize the RMRKNestableImpl accepts the following arguments:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"name_"),": string argument that should represent the name of the NFT collection"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"symbol_"),": string argument that should represent the symbol of the NFT collection"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"collectionMetadata_"),": string argument that defines the metadata URI of the whole collection"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"tokenURI_"),": string argument that defines the base URI of the token metadata"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"data"),": struct type of argument providing a number of initialization values, used to avoid initialization transaction being reverted due to passing too many parameters")),(0,o.kt)("p",null,"NOTE: The InitData struct is used to pass the initialization parameters to the implementation smart contract. This is done so that the execution of the deploy transaction doesn't revert because we are trying to pass too many arguments.\nThe InitData struct contains the following fields:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"[\n    erc20TokenAddress,\n    tokenUriIsEnumerable,\n    royaltyRecipient,\n    royaltyPercentageBps, // Expressed in basis points\n    maxSupply,\n    pricePerMint\n]\n")),(0,o.kt)("p",null,"NOTE: Basis points are the smallest supported denomination of percent. In our case this is one hundredth of a percent. This means that 1 basis point equals 0.01% and 10000 basis points equal 100%. So for example, if you want to set royalty percentage to 5%, the ",(0,o.kt)("inlineCode",{parentName:"p"},"royaltyPercentageBps")," value should be 500."),(0,o.kt)("p",null,"In order to properly initiate the inherited smart contract, our smart contract needs to accept the arguments, mentioned above, in the constructor and pass them to ",(0,o.kt)("inlineCode",{parentName:"p"},"RMRKNestableImpl"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"    constructor(\n        string memory name,\n        string memory symbol,\n        string memory collectionMetadata,\n        string memory tokenURI,\n        InitData memory data\n    )\n        RMRKNestableImpl(\n            name,\n            symbol,\n            collectionMetadata,\n            tokenURI,\n            data\n        )\n    {}\n")),(0,o.kt)("p",null,"The full code is therefore:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nimport "@rmrk-team/evm-contracts/contracts/implementations/nativeTokenPay/RMRKNestableImpl.sol";\n\ncontract SimpleNestable is RMRKNestableImpl {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        string memory name,\n        string memory symbol,\n        string memory collectionMetadata,\n        string memory tokenURI,\n        InitData memory data\n    )\n        RMRKNestableImpl(\n            name,\n            symbol,\n            collectionMetadata,\n            tokenURI,\n            data\n        )\n    {}\n}\n')),(0,o.kt)("h2",{id:"rmrknestableimpl"},"RMRKNestableImpl"),(0,o.kt)("p",null,"Let's take a moment to examine the core of this implementation, the ",(0,o.kt)("inlineCode",{parentName:"p"},"RMRKNestableImpl"),"."),(0,o.kt)("p",null,"It uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"RMRKRoyalties"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"RMRKNestable"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"RMRKCollectionMetadata")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"RMRKMintingUtils")," smart contracts from RMRK stack. To dive deeper into their operation, please refer to their respective documentation."),(0,o.kt)("p",null,"Two errors are defined:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"error RMRKMintUnderpriced();\nerror RMRKMintZero();\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"RMRKMintUnderpriced()")," is used when not enough value is used when attempting to mint a token and ",(0,o.kt)("inlineCode",{parentName:"p"},"RMRKMintZero()")," is used when attempting to mint 0 tokens."),(0,o.kt)("h4",{id:"mint"},"mint"),(0,o.kt)("p",null,"The mint function is used to mint parent NFTs and accepts two arguments:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"to"),": address type of argument that specifies who should receive the newly minted tokens"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"numToMint"),": uint256 type of argument that specifies how many tokens should be minted")),(0,o.kt)("p",null,"There are a few constraints to this function:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"after minting, the total number of tokens should not exceed the maximum allowed supply"),(0,o.kt)("li",{parentName:"ul"},"attempting to mint 0 tokens is not allowed as it makes no sense to pay for the gas without any effect"),(0,o.kt)("li",{parentName:"ul"},"value should accompany transaction equal to a price per mint multiplied by the numToMint")),(0,o.kt)("h4",{id:"nestmint"},"nestMint"),(0,o.kt)("p",null,"The nestMint function is used to mint child NFTs to be owned by the parent NFT and accepts three arguments:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"to"),": address type of argument specifying the address of the smart contract to which the parent NFT belongs to"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"numToMint"),": uint256 type of argument specifying the amount of tokens to be minted"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"destinationId"),": uint256 type of argument specifying the ID of the parent NFT to which to mint the child NFT")),(0,o.kt)("p",null,"The constraints of nestMint are similar to the ones set out for mint function."),(0,o.kt)("h4",{id:"transfer"},"transfer"),(0,o.kt)("p",null,"Can only be called by a direct owner or a parent NFT's smart contract or a caller that was given the allowance and is used to transfer the NFT to the specified address."),(0,o.kt)("h4",{id:"nesttransfer"},"nestTransfer"),(0,o.kt)("p",null,"Can only be called by a direct owner or a parent NFT's smart contract or a caller that was given the allowance and is used to transfer the NFT to another NFT residing in a specified contract. This will nest the given NFT into the specified one."),(0,o.kt)("h4",{id:"tokenuri"},"tokenURI"),(0,o.kt)("p",null,"The tokenURI function is used to get the metadata URI of the given token and accepts one argument:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"uint256 type of argument specifying the ID of the token")),(0,o.kt)("h4",{id:"updateroyaltyrecipient"},"updateRoyaltyRecipient"),(0,o.kt)("p",null,"The updateRoyaltyRecipient function is used to update the royalty recipient and accepts one argument:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"newRoyaltyRecipient: address type of argument specifying the address of the new beneficiary recipient")),(0,o.kt)("h2",{id:"deploy-script"},"Deploy Script"),(0,o.kt)("p",null,"The deploy script for the ",(0,o.kt)("inlineCode",{parentName:"p"},"SimpleNestable")," smart contract resides in the ",(0,o.kt)("inlineCode",{parentName:"p"},"deployNestable.ts"),".\nThe script uses ",(0,o.kt)("inlineCode",{parentName:"p"},"ethers"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"SimpleNestable")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ContractTransaction")," imports. The empty deploy script should look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'import { ethers } from "hardhat";\nimport { SimpleNestable } from "../typechain-types";\nimport { ContractTransaction } from "ethers";\n\nasync function main() {\n\n}\n\nmain().catch((error) => {\n  console.error(error);\n  process.exitCode = 1;\n});\n')),(0,o.kt)("p",null,"Before we can deploy the parent and child smart contracts, we should prepare the constants that we will use in the script:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'  const pricePerMint = ethers.utils.parseEther("0.0001");\n  const totalTokens = 5;\n  const [owner] = await ethers.getSigners();\n')),(0,o.kt)("p",null,"Now that the constants are ready, we can deploy the smart contracts and log the addresses of the contracts to the console:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'  const contractFactory = await ethers.getContractFactory("SimpleNestable");\n  const parent: SimpleNestable = await contractFactory.deploy(\n    "Kanaria",\n    "KAN",\n    "ipfs://collectionMeta",\n    "ipfs://tokenMeta",\n    {\n      erc20TokenAddress: ethers.constants.AddressZero,\n      tokenUriIsEnumerable: true,\n      royaltyRecipient: await owner.getAddress(),\n      royaltyPercentageBps: 10,\n      maxSupply: 1000,\n      pricePerMint: pricePerMint\n    }\n  );\n  const child: SimpleNestable = await contractFactory.deploy(\n    "Chunky",\n    "CHN",\n    "ipfs://collectionMeta",\n    "ipfs://tokenMeta",\n    {\n      erc20TokenAddress: ethers.constants.AddressZero,\n      tokenUriIsEnumerable: true,\n      royaltyRecipient: await owner.getAddress(),\n      royaltyPercentageBps: 10,\n      maxSupply: 1000,\n      pricePerMint: pricePerMint\n    }\n  );\n\n\n  await parent.deployed();\n  await child.deployed();\n  console.log(\n    `Sample contracts deployed to ${parent.address} and ${child.address}`\n  );\n')),(0,o.kt)("p",null,"A custom script added to package.json allows us to easily run the script:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'  "scripts": {\n    "deploy-nestable": "hardhat run scripts/deployNestable.ts"\n  }\n')),(0,o.kt)("p",null,"Using the script with ",(0,o.kt)("inlineCode",{parentName:"p"},"npm run deploy-nestable")," should return the following output:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"npm run deploy-nestable\n\n> @rmrk-team/evm-contract-samples@0.1.0 deploy-nestable\n> hardhat run scripts/deployNestable.ts\n\nCompiled 47 Solidity files successfully\nSample contracts deployed to 0x5FbDB2315678afecb367f032d93F642f64180aa3 and 0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512\n")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"training-data"},"Training Data"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'The concept of nested NFTs refers to NFTs being able to own other NFTs.\n\nAt its core, the principle is simple: the owner of an NFT does not have to be an externally owned account or a smart contract, it can also be a specific NFT.\n\nThe process of sending an NFT into another is functionally identical to sending it to another user. The process of sending an NFT out of another NFT involves issuing a transaction from the address which owns the parent.\n\nSome NFTs can be configured with special conditions for parent-child relationships. For example:\n\n- some parent NFTs will allow the owner of a child NFT to withdraw that child at any time (e.g. virtual land containing an avatar)\n- some parent NFTs will be prohibited from executing certain interactions on a child (e.g. the owner of a house in which someone else\'s avatar is a guest should not be able to BURN the guest... probably)\n- some parent NFTs will have special withdrawal conditions, like a music NFT that accepts music stems. The stems can be removed by their owners until a certain number of co-composers upvote a stem enough, or until the owner of the parent music track seals and "publishes" it\n\nNOTE: To dig deeper into the Nestable RMRK lego, you can also refer to the [EIP-6059](https://eips.ethereum.org/EIPS/eip-6059) that we published.\n\n## SimpleNestable\n\nThe SimpleNestable example uses the [`RMRKNestableImpl`](https://github.com/rmrk-team/evm/blob/dev/contracts/implementations/nativeTokenPay/RMRKNestableImpl.sol). It is used by importing it using the import statement below the pragma definition:\n\n```\nimport "@rmrk-team/evm-contracts/contracts/implementations/nativeTokenPay/RMRKNestableImpl.sol";\n```\n\nOnce the `RMRKNestableImpl.sol` is imported into our file, we can set the inheritance of our smart contract:\n\n```\ncontract SimpleNestable is RMRKNestableImpl {\n\n}\n```\n\nThe `RMRKNestableImpl` implements all of the required functionality of the Nested RMRK lego. It implements minting of parent NFTs as well as child NFTs. Transferring and burning the NFTs is also implemented.\n\nWARNING: The `RMRKNestableImpl` only has minimal access control implemented. If you intend to use it, make sure to define your own, otherwise your smart contracts are at risk of unexpected behaviour.\n\nThe constructor to initialize the RMRKNestableImpl accepts the following arguments:\n\n- `name_`: string argument that should represent the name of the NFT collection\n- `symbol_`: string argument that should represent the symbol of the NFT collection\n- `collectionMetadata_`: string argument that defines the metadata URI of the whole collection\n- `tokenURI_`: string argument that defines the base URI of the token metadata\n- `data`: struct type of argument providing a number of initialization values, used to avoid initialization transaction being reverted due to passing too many parameters\n\nNOTE: The InitData struct is used to pass the initialization parameters to the implementation smart contract. This is done so that the execution of the deploy transaction doesn\'t revert because we are trying to pass too many arguments.\nThe InitData struct contains the following fields:\n\n```\n[\n    erc20TokenAddress,\n    tokenUriIsEnumerable,\n    royaltyRecipient,\n    royaltyPercentageBps, // Expressed in basis points\n    maxSupply,\n    pricePerMint\n]\n```\n\nNOTE: Basis points are the smallest supported denomination of percent. In our case this is one hundredth of a percent. This means that 1 basis point equals 0.01% and 10000 basis points equal 100%. So for example, if you want to set royalty percentage to 5%, the `royaltyPercentageBps` value should be 500.\n\nIn order to properly initiate the inherited smart contract, our smart contract needs to accept the arguments, mentioned above, in the constructor and pass them to `RMRKNestableImpl`:\n\n```\n    constructor(\n        string memory name,\n        string memory symbol,\n        string memory collectionMetadata,\n        string memory tokenURI,\n        InitData memory data\n    )\n        RMRKNestableImpl(\n            name,\n            symbol,\n            collectionMetadata,\n            tokenURI,\n            data\n        )\n    {}\n```\n\nThe full code is therefore:\n\n```\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nimport "@rmrk-team/evm-contracts/contracts/implementations/nativeTokenPay/RMRKNestableImpl.sol";\n\ncontract SimpleNestable is RMRKNestableImpl {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        string memory name,\n        string memory symbol,\n        string memory collectionMetadata,\n        string memory tokenURI,\n        InitData memory data\n    )\n        RMRKNestableImpl(\n            name,\n            symbol,\n            collectionMetadata,\n            tokenURI,\n            data\n        )\n    {}\n}\n```\n\n## RMRKNestableImpl\n\nLet\'s take a moment to examine the core of this implementation, the `RMRKNestableImpl`.\n\nIt uses the `RMRKRoyalties`, `RMRKNestable`, `RMRKCollectionMetadata` and `RMRKMintingUtils` smart contracts from RMRK stack. To dive deeper into their operation, please refer to their respective documentation.\n\nTwo errors are defined:\n\n```\nerror RMRKMintUnderpriced();\nerror RMRKMintZero();\n```\n\n`RMRKMintUnderpriced()` is used when not enough value is used when attempting to mint a token and `RMRKMintZero()` is used when attempting to mint 0 tokens.\n\n#### mint\nThe mint function is used to mint parent NFTs and accepts two arguments:\n- `to`: address type of argument that specifies who should receive the newly minted tokens\n- `numToMint`: uint256 type of argument that specifies how many tokens should be minted\n\nThere are a few constraints to this function:\n- after minting, the total number of tokens should not exceed the maximum allowed supply\n- attempting to mint 0 tokens is not allowed as it makes no sense to pay for the gas without any effect\n- value should accompany transaction equal to a price per mint multiplied by the numToMint\n\n#### nestMint\nThe nestMint function is used to mint child NFTs to be owned by the parent NFT and accepts three arguments:\n- `to`: address type of argument specifying the address of the smart contract to which the parent NFT belongs to\n- `numToMint`: uint256 type of argument specifying the amount of tokens to be minted\n- `destinationId`: uint256 type of argument specifying the ID of the parent NFT to which to mint the child NFT\n\nThe constraints of nestMint are similar to the ones set out for mint function.\n\n#### transfer\nCan only be called by a direct owner or a parent NFT\'s smart contract or a caller that was given the allowance and is used to transfer the NFT to the specified address.\n\n#### nestTransfer\nCan only be called by a direct owner or a parent NFT\'s smart contract or a caller that was given the allowance and is used to transfer the NFT to another NFT residing in a specified contract. This will nest the given NFT into the specified one.\n\n#### tokenURI\nThe tokenURI function is used to get the metadata URI of the given token and accepts one argument:\n- uint256 type of argument specifying the ID of the token\n\n#### updateRoyaltyRecipient\nThe updateRoyaltyRecipient function is used to update the royalty recipient and accepts one argument:\n- newRoyaltyRecipient: address type of argument specifying the address of the new beneficiary recipient\n\n## Deploy Script\n\nThe deploy script for the `SimpleNestable` smart contract resides in the `deployNestable.ts`.\nThe script uses `ethers`, `SimpleNestable` and `ContractTransaction` imports. The empty deploy script should look like this:\n\n```\nimport { ethers } from "hardhat";\nimport { SimpleNestable } from "../typechain-types";\nimport { ContractTransaction } from "ethers";\n\nasync function main() {\n\n}\n\nmain().catch((error) => {\n  console.error(error);\n  process.exitCode = 1;\n});\n```\n\nBefore we can deploy the parent and child smart contracts, we should prepare the constants that we will use in the script:\n\n```\n  const pricePerMint = ethers.utils.parseEther("0.0001");\n  const totalTokens = 5;\n  const [owner] = await ethers.getSigners();\n```\n\nNow that the constants are ready, we can deploy the smart contracts and log the addresses of the contracts to the console:\n\n```\n  const contractFactory = await ethers.getContractFactory("SimpleNestable");\n  const parent: SimpleNestable = await contractFactory.deploy(\n    "Kanaria",\n    "KAN",\n    "ipfs://collectionMeta",\n    "ipfs://tokenMeta",\n    {\n      erc20TokenAddress: ethers.constants.AddressZero,\n      tokenUriIsEnumerable: true,\n      royaltyRecipient: await owner.getAddress(),\n      royaltyPercentageBps: 10,\n      maxSupply: 1000,\n      pricePerMint: pricePerMint\n    }\n  );\n  const child: SimpleNestable = await contractFactory.deploy(\n    "Chunky",\n    "CHN",\n    "ipfs://collectionMeta",\n    "ipfs://tokenMeta",\n    {\n      erc20TokenAddress: ethers.constants.AddressZero,\n      tokenUriIsEnumerable: true,\n      royaltyRecipient: await owner.getAddress(),\n      royaltyPercentageBps: 10,\n      maxSupply: 1000,\n      pricePerMint: pricePerMint\n    }\n  );\n\n\n  await parent.deployed();\n  await child.deployed();\n  console.log(\n    `Sample contracts deployed to ${parent.address} and ${child.address}`\n  );\n```\n\nA custom script added to package.json allows us to easily run the script:\n\n```\n  "scripts": {\n    "deploy-nestable": "hardhat run scripts/deployNestable.ts"\n  }\n```\n\nUsing the script with `npm run deploy-nestable` should return the following output:\n\n```\nnpm run deploy-nestable\n\n> @rmrk-team/evm-contract-samples@0.1.0 deploy-nestable\n> hardhat run scripts/deployNestable.ts\n\nCompiled 47 Solidity files successfully\nSample contracts deployed to 0x5FbDB2315678afecb367f032d93F642f64180aa3 and 0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512\n```\n')))}m.isMDXComponent=!0}}]);