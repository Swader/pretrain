"use strict";(self.webpackChunkpretrain=self.webpackChunkpretrain||[]).push([[284],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>k});var o=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,o,s=function(e,t){if(null==e)return{};var n,o,s={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=o.createContext({}),d=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=d(e.components);return o.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,s=e.mdxType,a=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=d(n),p=s,k=u["".concat(l,".").concat(p)]||u[p]||m[p]||a;return n?o.createElement(k,i(i({ref:t},c),{},{components:n})):o.createElement(k,i({ref:t},c))}));function k(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var a=n.length,i=new Array(a);i[0]=p;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[u]="string"==typeof e?e:s,i[1]=r;for(var d=2;d<a;d++)i[d]=n[d];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},9272:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>d});var o=n(7462),s=(n(7294),n(3905));const a={sidebar_position:19},i="EVM, nestable and multi asset, part 2",r={unversionedId:"rmrk/evm-nma-p2",id:"rmrk/evm-nma-p2",title:"EVM, nestable and multi asset, part 2",description:"User Journey",source:"@site/docs/rmrk/evm-nma-p2.md",sourceDirName:"rmrk",slug:"/rmrk/evm-nma-p2",permalink:"/docs/rmrk/evm-nma-p2",draft:!1,editUrl:"https://github.com/swader/pretrain/docs/rmrk/evm-nma-p2.md",tags:[],version:"current",sidebarPosition:19,frontMatter:{sidebar_position:19},sidebar:"tutorialSidebar",previous:{title:"EVM, nestable and multi asset, part 1",permalink:"/docs/rmrk/evm-nma-p1"},next:{title:"EVM, merged equippable p1",permalink:"/docs/rmrk/evm-mergedeq-p1"}},l={},d=[{value:"User Journey",id:"user-journey",level:2},{value:"AdvancedNestableMultiAsset",id:"advancednestablemultiasset",level:2},{value:"Training Data",id:"training-data",level:2}],c={toc:d};function u(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"evm-nestable-and-multi-asset-part-2"},"EVM, nestable and multi asset, part 2"),(0,s.kt)("h2",{id:"user-journey"},"User Journey"),(0,s.kt)("p",null,"With the deploy script ready, we can examine how the journey of a user using nestable with multi asset would look like using this smart contract.\nThe base of it is the same as the deploy script, as we need to deploy the smart contract in order to interact with it:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'import { ethers } from "hardhat";\nimport { SimpleNestableMultiAsset } from "../typechain-types";\nimport { ContractTransaction } from "ethers";\n\nasync function main() {\n  const pricePerMint = ethers.utils.parseEther("0.0000000001");\n  const totalTokens = 5;\n  const [ owner, tokenOwner] = await ethers.getSigners();\n\n  const contractFactory = await ethers.getContractFactory(\n    "SimpleNestableMultiAsset"\n  );\n  const token: SimpleNestableMultiAsset = await contractFactory.deploy(\n    {\n      erc20TokenAddress: ethers.constants.AddressZero,\n      tokenUriIsEnumerable: true,\n      royaltyRecipient: await owner.getAddress(),\n      royaltyPercentageBps: 10,\n      maxSupply: 1000,\n      pricePerMint: pricePerMint\n    }\n  );\n\n  await token.deployed();\n  console.log(`Sample contract deployed to ${token.address}`);\n}\n\nmain().catch((error) => {\n  console.error(error);\n  process.exitCode = 1;\n});\n')),(0,s.kt)("p",null,"NOTE: We assign the ",(0,s.kt)("inlineCode",{parentName:"p"},"tokenOwner")," the second available signer, so that the assets are not automatically accepted when added to the token. This happens when an account adding an asset to a token is also the owner of said token."),(0,s.kt)("p",null,"First thing that needs to be done after the smart contracts are deployed is to mint the NFTs. We will use the ",(0,s.kt)("inlineCode",{parentName:"p"},"totalTokens")," constant in order to specify how many of the tokens to mint:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'  console.log("Minting NFTs");\n  let tx = await token.mint(tokenOwner.address, totalTokens, {\n    value: pricePerMint.mul(totalTokens),\n  });\n  await tx.wait();\n  console.log(`Minted ${totalTokens} tokens`);\n  const totalSupply = await token.totalSupply();\n  console.log("Total tokens: %s", totalSupply);\n')),(0,s.kt)("p",null,"Now that the tokens are minted, we can add new assets to the smart contract. We will prepare a batch of transactions that will add simple IPFS metadata link for the assets in the smart contract. Once the transactions are ready, we will send them and get all of the assets to output to the console:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'  console.log("Adding assets");\n  let allTx: ContractTransaction[] = [];\n  for (let i = 1; i <= totalTokens; i++) {\n    let tx = await token.addAssetEntry(`ipfs://metadata/${i}.json`);\n    allTx.push(tx);\n  }\n  console.log(`Added ${totalTokens} assets`);\n\n  console.log("Awaiting for all tx to finish...");\n  await Promise.all(allTx.map((tx) => tx.wait()));\n')),(0,s.kt)("p",null,"Once the assets are added to the smart contract we can assign each asset to one of the tokens:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'  console.log("Adding assets to tokens");\n  allTx = [];\n  for (let i = 1; i <= totalTokens; i++) {\n    // We give each token a asset id with the same number. This is just a coincidence, not a restriction.\n    let tx = await token.addAssetToToken(i, i, 0);\n    allTx.push(tx);\n    console.log(`Added asset ${i} to token ${i}.`);\n  }\n  console.log("Awaiting for all tx to finish...");\n  await Promise.all(allTx.map((tx) => tx.wait()));\n')),(0,s.kt)("p",null,"After the assets are added to the NFTs, we have to accept them. We will do this by once again building a batch of transactions for each of the tokens and send them out one by one at the end:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'  console.log("Accepting assets to tokens");\n  allTx = [];\n  for (let i = 1; i <= totalTokens; i++) {\n    // Accept pending asset for each token (on index 0)\n    let tx = await token.connect(tokenOwner).acceptAsset(i, 0, i);\n    allTx.push(tx);\n    console.log(`Accepted first pending asset for token ${i}.`);\n  }\n  console.log("Awaiting for all tx to finish...");\n  await Promise.all(allTx.map((tx) => tx.wait()));\n')),(0,s.kt)("p",null,"Having accepted the assets, we can check that the URIs are assigned as expected:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'  console.log("Getting URIs");\n  const uriToken1 = await token.tokenURI(1);\n  const uriToken5 = await token.tokenURI(totalTokens);\n\n  console.log("Token 1 URI: ", uriToken1);\n  console.log("Token totalTokens URI: ", uriToken5);\n')),(0,s.kt)("p",null,"With the assets properly assigned to the tokens, we can now nest the token with ID 5 into the token with ID 1 and check their ownership to verify successful nesting:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'  console.log("Nesting token with ID 5 into token with ID 1");\n  await token.connect(tokenOwner).nestTransferFrom(tokenOwner.address, token.address, 5, 1, "0x");\n  const parentId = await token.ownerOf(5);\n  const rmrkParent = await token.directOwnerOf(5);\n  console.log("Token\'s id 5 owner  is ", parentId);\n  console.log("Token\'s id 5 rmrk owner is ", rmrkParent);\n')),(0,s.kt)("p",null,"We can now add a custom helper to the ",(0,s.kt)("inlineCode",{parentName:"p"},"package.json")," to make running it easier:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'    "user-journey-nestable-multi-asset": "hardhat run scripts/nestableMultiAssetUserJourney.ts"\n')),(0,s.kt)("p",null,"Running it using ",(0,s.kt)("inlineCode",{parentName:"p"},"npm run user-journey-nestable-multi-asset")," should return the following output:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'npm run user-journey-nestable-multi-asset\n\n> @rmrk-team/evm-contract-samples@0.1.0 user-journey-nestable-multi-asset\n> hardhat run scripts/nestableMultiAssetUserJourney.ts\n\nSample contract deployed to 0x5FbDB2315678afecb367f032d93F642f64180aa3\nMinting NFTs\nMinted 5 tokens\nTotal tokens: 5\nAdding assets\nAdded 5 assets\nAwaiting for all tx to finish...\nAll assets: [\n  BigNumber { value: "1" },\n  BigNumber { value: "2" },\n  BigNumber { value: "3" },\n  BigNumber { value: "4" },\n  BigNumber { value: "5" }\n]\nAdding assets to tokens\nAdded asset 1 to token 1.\nAdded asset 2 to token 2.\nAdded asset 3 to token 3.\nAdded asset 4 to token 4.\nAdded asset 5 to token 5.\nAwaiting for all tx to finish...\nAccepting assets to tokens\nAccepted first pending asset for token 1.\nAccepted first pending asset for token 2.\nAccepted first pending asset for token 3.\nAccepted first pending asset for token 4.\nAccepted first pending asset for token 5.\nAwaiting for all tx to finish...\nGetting URIs\nToken 1 URI:  ipfs://metadata/1.json\nToken totalTokens URI:  ipfs://metadata/5.json\nNesting token with ID 5 into token with ID 1\nToken\'s id 5 owner  is  0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\nToken\'s id 5 rmrk owner is  [\n  \'0x5FbDB2315678afecb367f032d93F642f64180aa3\',\n  BigNumber { value: "1" },\n  true\n]\n')),(0,s.kt)("h2",{id:"advancednestablemultiasset"},"AdvancedNestableMultiAsset"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"AdvancedNestableMultiAsset")," smart contract allows for more flexibility when using the nestable and multi asset legos together. It implements the minimum required implementation in order to be compatible with RMRK nestable and multi asset, but leaves more business logic implementation freedom to the developer. It uses the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/rmrk-team/evm/blob/dev/contracts/RMRK/nestable/RMRKNestableMultiAsset.sol"},(0,s.kt)("inlineCode",{parentName:"a"},"RMRKNestableMultiAsset.sol"))," import to gain access to the joined Nestable and Multi asset legos:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'import "@rmrk-team/evm-contracts/contracts/RMRK/nestable/RMRKNestableMultiAsset.sol";\n')),(0,s.kt)("p",null,"We only need ",(0,s.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"symbol")," of the NFT in order to properly initialize it after the ",(0,s.kt)("inlineCode",{parentName:"p"},"AdvancedNestableMultiAsset")," inherits it:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"contract AdvancedNestableMultiAsset is RMRKNestableMultiAsset {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        string memory name,\n        string memory symbol\n    )\n        RMRKNestableMultiAsset(name, symbol)\n    {\n        // Custom optional: constructor logic\n    }\n}\n")),(0,s.kt)("p",null,"The full code would look like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.16;\n\nimport "@rmrk-team/evm-contracts/contracts/RMRK/nestable/RMRKNestableMultiAsset.sol";\n\ncontract AdvancedNestableMultiAsset is RMRKNestableMultiAsset {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        string memory name,\n        string memory symbol\n    )\n        RMRKNestableMultiAsset(name, symbol)\n    {\n        // Custom optional: constructor logic\n    }\n}\n')),(0,s.kt)("p",null,"Using ",(0,s.kt)("inlineCode",{parentName:"p"},"RMRKNestableMultiAsset")," requires custom implementation of minting logic. Available internal functions to use when writing it are:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"_mint(address to, uint256 tokenId)")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"_safeMint(address to, uint256 tokenId)")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"_safeMint(address to, uint256 tokenId, bytes memory data)")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"_nestMint(address to, uint256 tokenId, uint256 destinationId)"))),(0,s.kt)("p",null,"The latter is used to nest mint the NFT directly to the parent NFT. If you intend to support it at the minting stage, you should implement it in your smart contract."),(0,s.kt)("p",null,"In addition to the minting functions, you should also implement the burning, transfer and asset management functions if they apply to your use case:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"_burn(uint256 tokenId)")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"transferFrom(address from, address to, uint256 tokenId)")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"nestTransfer(address from, address to, uint256 tokenId, uint256 destinationId)")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"_addAssetEntry(uint64 id, string memory metadataURI)")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"_addAssetToToken(uint256 tokenId, uint64 assetId, uint64 overwrites)"))),(0,s.kt)("p",null,"Any additional function supporting your NFT use case and utility can also be added. Remember to thoroughly test your smart contracts with extensive test suites and define strict access control rules for the functions that you implement."),(0,s.kt)("hr",null),(0,s.kt)("h2",{id:"training-data"},"Training Data"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'## User Journey\n\nWith the deploy script ready, we can examine how the journey of a user using nestable with multi asset would look like using this smart contract.\nThe base of it is the same as the deploy script, as we need to deploy the smart contract in order to interact with it:\n\n```\nimport { ethers } from "hardhat";\nimport { SimpleNestableMultiAsset } from "../typechain-types";\nimport { ContractTransaction } from "ethers";\n\nasync function main() {\n  const pricePerMint = ethers.utils.parseEther("0.0000000001");\n  const totalTokens = 5;\n  const [ owner, tokenOwner] = await ethers.getSigners();\n\n  const contractFactory = await ethers.getContractFactory(\n    "SimpleNestableMultiAsset"\n  );\n  const token: SimpleNestableMultiAsset = await contractFactory.deploy(\n    {\n      erc20TokenAddress: ethers.constants.AddressZero,\n      tokenUriIsEnumerable: true,\n      royaltyRecipient: await owner.getAddress(),\n      royaltyPercentageBps: 10,\n      maxSupply: 1000,\n      pricePerMint: pricePerMint\n    }\n  );\n\n  await token.deployed();\n  console.log(`Sample contract deployed to ${token.address}`);\n}\n\nmain().catch((error) => {\n  console.error(error);\n  process.exitCode = 1;\n});\n```\n\nNOTE: We assign the `tokenOwner` the second available signer, so that the assets are not automatically accepted when added to the token. This happens when an account adding an asset to a token is also the owner of said token.\n\nFirst thing that needs to be done after the smart contracts are deployed is to mint the NFTs. We will use the `totalTokens` constant in order to specify how many of the tokens to mint:\n\n```\n  console.log("Minting NFTs");\n  let tx = await token.mint(tokenOwner.address, totalTokens, {\n    value: pricePerMint.mul(totalTokens),\n  });\n  await tx.wait();\n  console.log(`Minted ${totalTokens} tokens`);\n  const totalSupply = await token.totalSupply();\n  console.log("Total tokens: %s", totalSupply);\n```\n\nNow that the tokens are minted, we can add new assets to the smart contract. We will prepare a batch of transactions that will add simple IPFS metadata link for the assets in the smart contract. Once the transactions are ready, we will send them and get all of the assets to output to the console:\n\n```\n  console.log("Adding assets");\n  let allTx: ContractTransaction[] = [];\n  for (let i = 1; i <= totalTokens; i++) {\n    let tx = await token.addAssetEntry(`ipfs://metadata/${i}.json`);\n    allTx.push(tx);\n  }\n  console.log(`Added ${totalTokens} assets`);\n\n  console.log("Awaiting for all tx to finish...");\n  await Promise.all(allTx.map((tx) => tx.wait()));\n```\n\nOnce the assets are added to the smart contract we can assign each asset to one of the tokens:\n\n```\n  console.log("Adding assets to tokens");\n  allTx = [];\n  for (let i = 1; i <= totalTokens; i++) {\n    // We give each token a asset id with the same number. This is just a coincidence, not a restriction.\n    let tx = await token.addAssetToToken(i, i, 0);\n    allTx.push(tx);\n    console.log(`Added asset ${i} to token ${i}.`);\n  }\n  console.log("Awaiting for all tx to finish...");\n  await Promise.all(allTx.map((tx) => tx.wait()));\n```\n\nAfter the assets are added to the NFTs, we have to accept them. We will do this by once again building a batch of transactions for each of the tokens and send them out one by one at the end:\n\n```\n  console.log("Accepting assets to tokens");\n  allTx = [];\n  for (let i = 1; i <= totalTokens; i++) {\n    // Accept pending asset for each token (on index 0)\n    let tx = await token.connect(tokenOwner).acceptAsset(i, 0, i);\n    allTx.push(tx);\n    console.log(`Accepted first pending asset for token ${i}.`);\n  }\n  console.log("Awaiting for all tx to finish...");\n  await Promise.all(allTx.map((tx) => tx.wait()));\n```\n\nHaving accepted the assets, we can check that the URIs are assigned as expected:\n\n```\n  console.log("Getting URIs");\n  const uriToken1 = await token.tokenURI(1);\n  const uriToken5 = await token.tokenURI(totalTokens);\n\n  console.log("Token 1 URI: ", uriToken1);\n  console.log("Token totalTokens URI: ", uriToken5);\n```\n\nWith the assets properly assigned to the tokens, we can now nest the token with ID 5 into the token with ID 1 and check their ownership to verify successful nesting:\n\n```\n  console.log("Nesting token with ID 5 into token with ID 1");\n  await token.connect(tokenOwner).nestTransferFrom(tokenOwner.address, token.address, 5, 1, "0x");\n  const parentId = await token.ownerOf(5);\n  const rmrkParent = await token.directOwnerOf(5);\n  console.log("Token\'s id 5 owner  is ", parentId);\n  console.log("Token\'s id 5 rmrk owner is ", rmrkParent);\n```\n\nWe can now add a custom helper to the `package.json` to make running it easier:\n\n```\n    "user-journey-nestable-multi-asset": "hardhat run scripts/nestableMultiAssetUserJourney.ts"\n```\n\nRunning it using `npm run user-journey-nestable-multi-asset` should return the following output:\n\n```\nnpm run user-journey-nestable-multi-asset\n\n> @rmrk-team/evm-contract-samples@0.1.0 user-journey-nestable-multi-asset\n> hardhat run scripts/nestableMultiAssetUserJourney.ts\n\nSample contract deployed to 0x5FbDB2315678afecb367f032d93F642f64180aa3\nMinting NFTs\nMinted 5 tokens\nTotal tokens: 5\nAdding assets\nAdded 5 assets\nAwaiting for all tx to finish...\nAll assets: [\n  BigNumber { value: "1" },\n  BigNumber { value: "2" },\n  BigNumber { value: "3" },\n  BigNumber { value: "4" },\n  BigNumber { value: "5" }\n]\nAdding assets to tokens\nAdded asset 1 to token 1.\nAdded asset 2 to token 2.\nAdded asset 3 to token 3.\nAdded asset 4 to token 4.\nAdded asset 5 to token 5.\nAwaiting for all tx to finish...\nAccepting assets to tokens\nAccepted first pending asset for token 1.\nAccepted first pending asset for token 2.\nAccepted first pending asset for token 3.\nAccepted first pending asset for token 4.\nAccepted first pending asset for token 5.\nAwaiting for all tx to finish...\nGetting URIs\nToken 1 URI:  ipfs://metadata/1.json\nToken totalTokens URI:  ipfs://metadata/5.json\nNesting token with ID 5 into token with ID 1\nToken\'s id 5 owner  is  0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\nToken\'s id 5 rmrk owner is  [\n  \'0x5FbDB2315678afecb367f032d93F642f64180aa3\',\n  BigNumber { value: "1" },\n  true\n]\n```\n\n## AdvancedNestableMultiAsset\n\nThe `AdvancedNestableMultiAsset` smart contract allows for more flexibility when using the nestable and multi asset legos together. It implements the minimum required implementation in order to be compatible with RMRK nestable and multi asset, but leaves more business logic implementation freedom to the developer. It uses the [`RMRKNestableMultiAsset.sol`](https://github.com/rmrk-team/evm/blob/dev/contracts/RMRK/nestable/RMRKNestableMultiAsset.sol) import to gain access to the joined Nestable and Multi asset legos:\n\n```\nimport "@rmrk-team/evm-contracts/contracts/RMRK/nestable/RMRKNestableMultiAsset.sol";\n```\n\nWe only need `name` and `symbol` of the NFT in order to properly initialize it after the `AdvancedNestableMultiAsset` inherits it:\n\n```\ncontract AdvancedNestableMultiAsset is RMRKNestableMultiAsset {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        string memory name,\n        string memory symbol\n    )\n        RMRKNestableMultiAsset(name, symbol)\n    {\n        // Custom optional: constructor logic\n    }\n}\n```\n\nThe full code would look like this:\n\n```\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.16;\n\nimport "@rmrk-team/evm-contracts/contracts/RMRK/nestable/RMRKNestableMultiAsset.sol";\n\ncontract AdvancedNestableMultiAsset is RMRKNestableMultiAsset {\n    // NOTE: Additional custom arguments can be added to the constructor based on your needs.\n    constructor(\n        string memory name,\n        string memory symbol\n    )\n        RMRKNestableMultiAsset(name, symbol)\n    {\n        // Custom optional: constructor logic\n    }\n}\n```\n\nUsing `RMRKNestableMultiAsset` requires custom implementation of minting logic. Available internal functions to use when writing it are:\n\n- `_mint(address to, uint256 tokenId)`\n- `_safeMint(address to, uint256 tokenId)`\n- `_safeMint(address to, uint256 tokenId, bytes memory data)`\n- `_nestMint(address to, uint256 tokenId, uint256 destinationId)`\n\nThe latter is used to nest mint the NFT directly to the parent NFT. If you intend to support it at the minting stage, you should implement it in your smart contract.\n\nIn addition to the minting functions, you should also implement the burning, transfer and asset management functions if they apply to your use case:\n\n- `_burn(uint256 tokenId)`\n- `transferFrom(address from, address to, uint256 tokenId)`\n- `nestTransfer(address from, address to, uint256 tokenId, uint256 destinationId)`\n- `_addAssetEntry(uint64 id, string memory metadataURI)`\n- `_addAssetToToken(uint256 tokenId, uint64 assetId, uint64 overwrites)`\n\nAny additional function supporting your NFT use case and utility can also be added. Remember to thoroughly test your smart contracts with extensive test suites and define strict access control rules for the functions that you implement.\n')))}u.isMDXComponent=!0}}]);