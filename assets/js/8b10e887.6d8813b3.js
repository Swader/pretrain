"use strict";(self.webpackChunkpretrain=self.webpackChunkpretrain||[]).push([[1461],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>h});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(t),u=o,h=c["".concat(l,".").concat(u)]||c[u]||m[u]||i;return t?a.createElement(h,r(r({ref:n},d),{},{components:t})):a.createElement(h,r({ref:n},d))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,r=new Array(i);r[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[c]="string"==typeof e?e:o,r[1]=s;for(var p=2;p<i;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},5460:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=t(7462),o=(t(7294),t(3905));const i={sidebar_position:21},r="EVM, merged equippable p2",s={unversionedId:"rmrk/evm-mergedeq-p2",id:"rmrk/evm-mergedeq-p2",title:"EVM, merged equippable p2",description:"Deploy Script",source:"@site/docs/rmrk/evm-mergedeq-p2.md",sourceDirName:"rmrk",slug:"/rmrk/evm-mergedeq-p2",permalink:"/docs/rmrk/evm-mergedeq-p2",draft:!1,editUrl:"https://github.com/swader/pretrain/docs/rmrk/evm-mergedeq-p2.md",tags:[],version:"current",sidebarPosition:21,frontMatter:{sidebar_position:21},sidebar:"tutorialSidebar",previous:{title:"EVM, merged equippable p1",permalink:"/docs/rmrk/evm-mergedeq-p1"},next:{title:"EVM, merged equippable p3",permalink:"/docs/rmrk/evm-mergedeq-p3"}},l={},p=[{value:"Deploy Script",id:"deploy-script",level:2},{value:"User Journey",id:"user-journey",level:2},{value:"Training Data",id:"training-data",level:2}],d={toc:p};function c(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"evm-merged-equippable-p2"},"EVM, merged equippable p2"),(0,o.kt)("h2",{id:"deploy-script"},"Deploy Script"),(0,o.kt)("p",null,"The deploy script for simple MergedEquippable resides in the ",(0,o.kt)("inlineCode",{parentName:"p"},"deployEquippable.ts"),"."),(0,o.kt)("p",null,"The deploy script uses the ethers, ",(0,o.kt)("inlineCode",{parentName:"p"},"SimpleCatalog"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"SimpleEquippable"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"RMRKEquipRenderUtils")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ContractTransaction")," imports. We will also define the ",(0,o.kt)("inlineCode",{parentName:"p"},"pricePerMint")," constant, which will be used to set the minting price of the tokens. The empty deploy script should look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'import { ethers } from "hardhat";\nimport {\n  SimpleCatalog,\n  SimpleEquippable,\n  RMRKEquipRenderUtils,\n} from "../typechain-types";\nimport { ContractTransaction } from "ethers";\n\nconst pricePerMint = ethers.utils.parseEther("0.0001");\n\nasync function main() {\n    \n}\n\nmain().catch((error) => {\n  console.error(error);\n  process.exitCode = 1;\n});\n')),(0,o.kt)("p",null,"Since we will expand upon this deploy script in the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/rmrk-team/evm-dev-docs/blob/master/rmrk-legos-examples/broken-reference/README.md"},"user journey"),", we will add a deployContracts function. In it we will deploy two ",(0,o.kt)("inlineCode",{parentName:"p"},"SimpleEquippable")," smart contracts, one ",(0,o.kt)("inlineCode",{parentName:"p"},"SimpleCatalog")," smart contract and a ",(0,o.kt)("inlineCode",{parentName:"p"},"RMRKEquipRenderUtils")," smart contract. Once the smart contracts are deployed, we will output their addresses. The function is defined below the ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," function definition:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'async function deployContracts(): Promise<\n  [SimpleEquippable, SimpleEquippable, SimpleCatalog, RMRKEquipRenderUtils]\n> {\n  console.log("Deploying smart contracts");\n\n  const [beneficiary] = await ethers.getSigners();\n  const contractFactory = await ethers.getContractFactory("SimpleEquippable");\n  const catalogFactory = await ethers.getContractFactory("SimpleCatalog");\n  const viewsFactory = await ethers.getContractFactory("RMRKEquipRenderUtils");\n\n  const kanaria: SimpleEquippable = await contractFactory.deploy(\n    "Kanaria",\n    "KAN",\n    "ipfs://collectionMeta",\n    "ipfs://tokenMeta",\n    {\n      erc20TokenAddress: ethers.constants.AddressZero,\n      tokenUriIsEnumerable: true,\n      royaltyRecipient: await beneficiary.getAddress(),\n      royaltyPercentageBps: 10,\n      maxSupply: 1000,\n      pricePerMint: pricePerMint\n    }\n  );\n  const gem: SimpleEquippable = await contractFactory.deploy(\n    "Gem",\n    "GM",\n    "ipfs://collectionMeta",\n    "ipfs://tokenMeta",\n    {\n      erc20TokenAddress: ethers.constants.AddressZero,\n      tokenUriIsEnumerable: true,\n      royaltyRecipient: await beneficiary.getAddress(),\n      royaltyPercentageBps: 10,\n      maxSupply: 3000,\n      pricePerMint: pricePerMint\n    }\n  );\n  const catalog: SimpleCatalog = await catalogFactory.deploy("KB", "svg");\n  const views: RMRKEquipRenderUtils = await viewsFactory.deploy();\n\n  await kanaria.deployed();\n  await gem.deployed();\n  await catalog.deployed();\n  await views.deployed();\n  console.log(\n    `Sample contracts deployed to ${kanaria.address} (Kanaria), ${gem.address} (Gem) and ${catalog.address} (Catalog)`\n  );\n\n  return [kanaria, gem, catalog, views];\n}\n')),(0,o.kt)("p",null,"In order for the ",(0,o.kt)("inlineCode",{parentName:"p"},"deployContracts")," to be called when running the deploy script, we have to add it to the main function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"  const [kanaria, gem, catalog, views] = await deployContracts();\n")),(0,o.kt)("p",null,"A custom script added to ",(0,o.kt)("inlineCode",{parentName:"p"},"package.json")," allows us to easily run the script:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'  "scripts": {\n    "deploy-equippable": "hardhat run scripts/deployEquippable.ts"\n  }\n')),(0,o.kt)("p",null,"We use the script with ",(0,o.kt)("inlineCode",{parentName:"p"},"npm run deploy-equippable"),"."),(0,o.kt)("h2",{id:"user-journey"},"User Journey"),(0,o.kt)("p",null,"With the deploy script ready, we can examine how the journey of a user using merged equippable would look like."),(0,o.kt)("p",null,"The base of the user journey script is the same as the deploy script, as we need to deploy the smart contract in order to interact with it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'import { ethers } from "hardhat";\nimport {\n  SimpleCatalog,\n  SimpleEquippable,\n  RMRKEquipRenderUtils,\n} from "../typechain-types";\nimport { ContractTransaction } from "ethers";\n\nconst pricePerMint = ethers.utils.parseEther("0.0001");\n\nasync function main() {\n  const [kanaria, gem, catalog, views] = await deployContracts();\n}\n\nasync function deployContracts(): Promise<\n  [SimpleEquippable, SimpleEquippable, SimpleCatalog, RMRKEquipRenderUtils]\n> {\n  console.log("Deploying smart contracts");\n\n  const [beneficiary] = await ethers.getSigners();\n  const contractFactory = await ethers.getContractFactory("SimpleEquippable");\n  const catalogFactory = await ethers.getContractFactory("SimpleCatalog");\n  const viewsFactory = await ethers.getContractFactory("RMRKEquipRenderUtils");\n\n  const kanaria: SimpleEquippable = await contractFactory.deploy(\n    "Kanaria",\n    "KAN",\n    "ipfs://collectionMeta",\n    "ipfs://tokenMeta",\n    {\n      erc20TokenAddress: ethers.constants.AddressZero,\n      tokenUriIsEnumerable: true,\n      royaltyRecipient: await beneficiary.getAddress(),\n      royaltyPercentageBps: 10,\n      maxSupply: 1000,\n      pricePerMint: pricePerMint\n    }\n  );\n  const gem: SimpleEquippable = await contractFactory.deploy(\n    "Gem",\n    "GM",\n    "ipfs://collectionMeta",\n    "ipfs://tokenMeta",\n    {\n      erc20TokenAddress: ethers.constants.AddressZero,\n      tokenUriIsEnumerable: true,\n      royaltyRecipient: await beneficiary.getAddress(),\n      royaltyPercentageBps: 10,\n      maxSupply: 3000,\n      pricePerMint: pricePerMint\n    }\n  );\n  const catalog: SimpleCatalog = await catalogFactory.deploy("KB", "svg");\n  const views: RMRKEquipRenderUtils = await viewsFactory.deploy();\n\n  await kanaria.deployed();\n  await gem.deployed();\n  await catalog.deployed();\n  console.log(\n    `Sample contracts deployed to ${kanaria.address} (Kanaria), ${gem.address} (Gem) and ${catalog.address} (Catalog)`\n  );\n\n  return [kanaria, gem, catalog, views];\n}\n\nmain().catch((error) => {\n  console.error(error);\n  process.exitCode = 1;\n});\n')),(0,o.kt)("p",null,"Once the smart contracts are deployed, we can setup the Catalog. "),(0,o.kt)("p",null,"We will set it up have two fixed part options for background, head, body and wings. Additionally we will add three slot options for gems. All of these will be added using the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/rmrk-team/evm-dev-docs/blob/master/rmrk-legos-examples/broken-reference/README.md"},(0,o.kt)("inlineCode",{parentName:"a"},"addPartList"))," method. The call together with encapsulating ",(0,o.kt)("inlineCode",{parentName:"p"},"setupCatalog")," function should look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'async function setupCatalog(catalog: SimpleCatalog, gemAddress: string): Promise<void> {\n  console.log("Setting up Catalog");\n  // Setup catalog with 2 fixed part options for background, head, body and wings.\n  // Also 3 slot options for gems\n  const tx = await catalog.addPartList([\n    {\n      // Background option 1\n      partId: 1,\n      part: {\n        itemType: 2, // Fixed\n        z: 0,\n        equippable: [],\n        metadataURI: "ipfs://backgrounds/1.svg",\n      },\n    },\n    {\n      // Background option 2\n      partId: 2,\n      part: {\n        itemType: 2, // Fixed\n        z: 0,\n        equippable: [],\n        metadataURI: "ipfs://backgrounds/2.svg",\n      },\n    },\n    {\n      // Head option 1\n      partId: 3,\n      part: {\n        itemType: 2, // Fixed\n        z: 3,\n        equippable: [],\n        metadataURI: "ipfs://heads/1.svg",\n      },\n    },\n    {\n      // Head option 2\n      partId: 4,\n      part: {\n        itemType: 2, // Fixed\n        z: 3,\n        equippable: [],\n        metadataURI: "ipfs://heads/2.svg",\n      },\n    },\n    {\n      // Body option 1\n      partId: 5,\n      part: {\n        itemType: 2, // Fixed\n        z: 2,\n        equippable: [],\n        metadataURI: "ipfs://body/1.svg",\n      },\n    },\n    {\n      // Body option 2\n      partId: 6,\n      part: {\n        itemType: 2, // Fixed\n        z: 2,\n        equippable: [],\n        metadataURI: "ipfs://body/2.svg",\n      },\n    },\n    {\n      // Wings option 1\n      partId: 7,\n      part: {\n        itemType: 2, // Fixed\n        z: 1,\n        equippable: [],\n        metadataURI: "ipfs://wings/1.svg",\n      },\n    },\n    {\n      // Wings option 2\n      partId: 8,\n      part: {\n        itemType: 2, // Fixed\n        z: 1,\n        equippable: [],\n        metadataURI: "ipfs://wings/2.svg",\n      },\n    },\n    {\n      // Gems slot 1\n      partId: 9,\n      part: {\n        itemType: 1, // Slot\n        z: 4,\n        equippable: [gemAddress], // Only gems tokens can be equipped here\n        metadataURI: "",\n      },\n    },\n    {\n      // Gems slot 2\n      partId: 10,\n      part: {\n        itemType: 1, // Slot\n        z: 4,\n        equippable: [gemAddress], // Only gems tokens can be equipped here\n        metadataURI: "",\n      },\n    },\n    {\n      // Gems slot 3\n      partId: 11,\n      part: {\n        itemType: 1, // Slot\n        z: 4,\n        equippable: [gemAddress], // Only gems tokens can be equipped here\n        metadataURI: "",\n      },\n    },\n  ]);\n  await tx.wait();\n  console.log("Catalog is set");\n}\n')),(0,o.kt)("p",null,"NOTE: The ",(0,o.kt)("inlineCode",{parentName:"p"},"metadataURI")," of a slot can be used to retrieve a fallback asset when no asset is equipped into it."),(0,o.kt)("p",null,"Notice how the ",(0,o.kt)("inlineCode",{parentName:"p"},"z")," value of the background is ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," and that of the head is ",(0,o.kt)("inlineCode",{parentName:"p"},"3"),". Also note how the ",(0,o.kt)("inlineCode",{parentName:"p"},"itemType")," value of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Slot")," type of fixed items is ",(0,o.kt)("inlineCode",{parentName:"p"},"2")," and that of equippable items is ",(0,o.kt)("inlineCode",{parentName:"p"},"1"),". Additionally the ",(0,o.kt)("inlineCode",{parentName:"p"},"metadataURI")," is usually left blank for the equippables, but has to be set for the fixed items. The ",(0,o.kt)("inlineCode",{parentName:"p"},"equippable")," values have to be set to the gem smart contracts for the equippable items."),(0,o.kt)("p",null,"In order for the ",(0,o.kt)("inlineCode",{parentName:"p"},"setupCatalog")," to be called, we have to add it to the main function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"  await setupCatalog(catalog, gem.address);\n")),(0,o.kt)("p",null,"With the ",(0,o.kt)("inlineCode",{parentName:"p"},"Catalog")," set up, the tokens should now be minted. Both ",(0,o.kt)("inlineCode",{parentName:"p"},"Kanaria")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Gem")," tokens will be minted in the ",(0,o.kt)("inlineCode",{parentName:"p"},"mintTokens"),". To define how many tokens should be minted, ",(0,o.kt)("inlineCode",{parentName:"p"},"totalBirds")," constant will be added below the import statements:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"const totalBirds = 5;\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"mintToken")," function should accept two arguments (",(0,o.kt)("inlineCode",{parentName:"p"},"Kanaria")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Gem"),"). We will prepare a batch of transactions to mint the tokens and send them. Once the tokens are minted, we will output the total number of tokens minted. While the Kanaria tokens will be minted to the ",(0,o.kt)("inlineCode",{parentName:"p"},"tokenOwner")," address, the Gem tokens will be minted using the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/rmrk-team/evm-dev-docs/blob/master/rmrk-legos-examples/broken-reference/README.md"},(0,o.kt)("inlineCode",{parentName:"a"},"nestMint"))," method in order to be minted directly to the Kanaria tokens. We will mint three Gem tokens to each Kanaria. Since all of the nested tokens need to be approved, we will also build a batch of transaction to accept a single nest-minted ",(0,o.kt)("inlineCode",{parentName:"p"},"Gem")," for each ",(0,o.kt)("inlineCode",{parentName:"p"},"Kanaria"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'async function mintTokens(\n  kanaria: SimpleEquippable,\n  gem: SimpleEquippable\n): Promise<void> {\n  console.log("Minting tokens");\n  const [ , tokenOwner] = await ethers.getSigners();\n\n  // Mint some kanarias\n  console.log("Minting Kanaria tokens");\n  let tx = await kanaria.mint(tokenOwner.address, totalBirds, {\n    value: pricePerMint.mul(totalBirds),\n  });\n  await tx.wait();\n  console.log(`Minted ${totalBirds} kanarias`);\n\n  // Mint 3 gems into each kanaria\n  console.log("Nest-minting Gem tokens");\n  let allTx: ContractTransaction[] = [];\n  for (let i = 1; i <= totalBirds; i++) {\n    let tx = await gem.nestMint(kanaria.address, 3, i, {\n      value: pricePerMint.mul(3),\n    });\n    allTx.push(tx);\n  }\n  await Promise.all(allTx.map((tx) => tx.wait()));\n  console.log(`Minted 3 gems into each kanaria`);\n\n  // Accept 3 gems for each kanaria\n  console.log("Accepting Gems");\n  for (let tokenId = 1; tokenId <= totalBirds; tokenId++) {\n    allTx = [\n      await kanaria.connect(tokenOwner).acceptChild(tokenId, 2, gem.address, 3 * tokenId),\n      await kanaria.connect(tokenOwner).acceptChild(tokenId, 1, gem.address, 3 * tokenId - 1),\n      await kanaria.connect(tokenOwner).acceptChild(tokenId, 0, gem.address, 3 * tokenId - 2),\n    ];\n  }\n  await Promise.all(allTx.map((tx) => tx.wait()));\n  console.log(`Accepted gems for each kanaria`);\n}\n')),(0,o.kt)("p",null,"NOTE: We assign the ",(0,o.kt)("inlineCode",{parentName:"p"},"tokenOwner")," the second available signer, so that the assets are not automatically accepted when added to the token. This happens when an account adding an asset to a token is also the owner of said token."),(0,o.kt)("p",null,"In order for the ",(0,o.kt)("inlineCode",{parentName:"p"},"mintTokens")," to be called, we have to add it to the main function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"  await mintTokens(kanaria, gem);\n")),(0,o.kt)("p",null,"Having minted both ",(0,o.kt)("inlineCode",{parentName:"p"},"Kanarias")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Gems"),", we can now add assets to them. We will add assets to the Kanaria using the ",(0,o.kt)("inlineCode",{parentName:"p"},"addKanariaAssets")," function. It accepts ",(0,o.kt)("inlineCode",{parentName:"p"},"Kanaria")," and address of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Catalog")," smart contract. Assets will be added using the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/rmrk-team/evm-dev-docs/blob/master/rmrk-legos-examples/broken-reference/README.md"},(0,o.kt)("inlineCode",{parentName:"a"},"addEquippableAssetEntry"))," method. We will add a default asset, which doesn't need a ",(0,o.kt)("inlineCode",{parentName:"p"},"baseAddress")," value. The composed asset needs to have the baseAddress. We also specify the fixed parts IDs for background, head, body and wings. Additionally we allow the gems to be equipped in the slot parts IDs. With the asset entires added, we can add them to a token and then accept them as well:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'async function addKanariaAssets(\n  kanaria: SimpleEquippable,\n  baseAddress: string\n): Promise<void> {\n  console.log("Adding Kanaria assets");\n  const [ , tokenOwner] = await ethers.getSigners();\n  const assetDefaultId = 1;\n  const assetComposedId = 2;\n  let allTx: ContractTransaction[] = [];\n  let tx = await kanaria.addEquippableAssetEntry(\n    0, // Only used for assets meant to equip into others\n    ethers.constants.AddressZero, // catalog is not needed here\n    "ipfs://default.png",\n    []\n  );\n  allTx.push(tx);\n\n  tx = await kanaria.addEquippableAssetEntry(\n    0, // Only used for assets meant to equip into others\n    catalogAddress, // Since we\'re using parts, we must define the catalog\n    "ipfs://meta1.json",\n    [1, 3, 5, 7, 9, 10, 11] // We\'re using first background, head, body and wings and state that this can receive the 3 slot parts for gems\n  );\n  allTx.push(tx);\n  // Wait for both assets to be added\n  await Promise.all(allTx.map((tx) => tx.wait()));\n  console.log("Added 2 asset entries");\n\n  // Add assets to token\n  const tokenId = 1;\n  allTx = [\n    await kanaria.addAssetToToken(tokenId, assetDefaultId, 0),\n    await kanaria.addAssetToToken(tokenId, assetComposedId, 0),\n  ];\n  await Promise.all(allTx.map((tx) => tx.wait()));\n  console.log("Added assets to token 1");\n\n  // Accept both assets:\n  tx = await kanaria.connect(tokenOwner).acceptAsset(tokenId, 0, assetDefaultId);\n  await tx.wait();\n  tx = await kanaria.connect(tokenOwner).acceptAsset(tokenId, 0, assetComposedId);\n  await tx.wait();\n  console.log("Assets accepted");\n}\n')),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"training-data"},"Training Data"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'## Deploy Script\n\nThe deploy script for simple MergedEquippable resides in the `deployEquippable.ts`.\n\nThe deploy script uses the ethers, `SimpleCatalog`, `SimpleEquippable`, `RMRKEquipRenderUtils` and `ContractTransaction` imports. We will also define the `pricePerMint` constant, which will be used to set the minting price of the tokens. The empty deploy script should look like this:\n\n```\nimport { ethers } from "hardhat";\nimport {\nSimpleCatalog,\nSimpleEquippable,\nRMRKEquipRenderUtils,\n} from "../typechain-types";\nimport { ContractTransaction } from "ethers";\n\nconst pricePerMint = ethers.utils.parseEther("0.0001");\n\nasync function main() {\n    \n}\n\nmain().catch((error) => {\nconsole.error(error);\nprocess.exitCode = 1;\n});\n```\n\nSince we will expand upon this deploy script in the [user journey](https://github.com/rmrk-team/evm-dev-docs/blob/master/rmrk-legos-examples/broken-reference/README.md), we will add a deployContracts function. In it we will deploy two `SimpleEquippable` smart contracts, one `SimpleCatalog` smart contract and a `RMRKEquipRenderUtils` smart contract. Once the smart contracts are deployed, we will output their addresses. The function is defined below the `main` function definition:\n\n```\nasync function deployContracts(): Promise<\n[SimpleEquippable, SimpleEquippable, SimpleCatalog, RMRKEquipRenderUtils]\n> {\nconsole.log("Deploying smart contracts");\n\nconst [beneficiary] = await ethers.getSigners();\nconst contractFactory = await ethers.getContractFactory("SimpleEquippable");\nconst catalogFactory = await ethers.getContractFactory("SimpleCatalog");\nconst viewsFactory = await ethers.getContractFactory("RMRKEquipRenderUtils");\n\nconst kanaria: SimpleEquippable = await contractFactory.deploy(\n    "Kanaria",\n    "KAN",\n    "ipfs://collectionMeta",\n    "ipfs://tokenMeta",\n    {\n    erc20TokenAddress: ethers.constants.AddressZero,\n    tokenUriIsEnumerable: true,\n    royaltyRecipient: await beneficiary.getAddress(),\n    royaltyPercentageBps: 10,\n    maxSupply: 1000,\n    pricePerMint: pricePerMint\n    }\n);\nconst gem: SimpleEquippable = await contractFactory.deploy(\n    "Gem",\n    "GM",\n    "ipfs://collectionMeta",\n    "ipfs://tokenMeta",\n    {\n    erc20TokenAddress: ethers.constants.AddressZero,\n    tokenUriIsEnumerable: true,\n    royaltyRecipient: await beneficiary.getAddress(),\n    royaltyPercentageBps: 10,\n    maxSupply: 3000,\n    pricePerMint: pricePerMint\n    }\n);\nconst catalog: SimpleCatalog = await catalogFactory.deploy("KB", "svg");\nconst views: RMRKEquipRenderUtils = await viewsFactory.deploy();\n\nawait kanaria.deployed();\nawait gem.deployed();\nawait catalog.deployed();\nawait views.deployed();\nconsole.log(\n    `Sample contracts deployed to ${kanaria.address} (Kanaria), ${gem.address} (Gem) and ${catalog.address} (Catalog)`\n);\n\nreturn [kanaria, gem, catalog, views];\n}\n```\n\nIn order for the `deployContracts` to be called when running the deploy script, we have to add it to the main function:\n\n```\nconst [kanaria, gem, catalog, views] = await deployContracts();\n```\n\nA custom script added to `package.json` allows us to easily run the script:\n\n```\n"scripts": {\n    "deploy-equippable": "hardhat run scripts/deployEquippable.ts"\n}\n```\n\nWe use the script with `npm run deploy-equippable`.\n\n## User Journey\n\nWith the deploy script ready, we can examine how the journey of a user using merged equippable would look like.\n\nThe base of the user journey script is the same as the deploy script, as we need to deploy the smart contract in order to interact with it:\n\n```\nimport { ethers } from "hardhat";\nimport {\nSimpleCatalog,\nSimpleEquippable,\nRMRKEquipRenderUtils,\n} from "../typechain-types";\nimport { ContractTransaction } from "ethers";\n\nconst pricePerMint = ethers.utils.parseEther("0.0001");\n\nasync function main() {\nconst [kanaria, gem, catalog, views] = await deployContracts();\n}\n\nasync function deployContracts(): Promise<\n[SimpleEquippable, SimpleEquippable, SimpleCatalog, RMRKEquipRenderUtils]\n> {\nconsole.log("Deploying smart contracts");\n\nconst [beneficiary] = await ethers.getSigners();\nconst contractFactory = await ethers.getContractFactory("SimpleEquippable");\nconst catalogFactory = await ethers.getContractFactory("SimpleCatalog");\nconst viewsFactory = await ethers.getContractFactory("RMRKEquipRenderUtils");\n\nconst kanaria: SimpleEquippable = await contractFactory.deploy(\n    "Kanaria",\n    "KAN",\n    "ipfs://collectionMeta",\n    "ipfs://tokenMeta",\n    {\n    erc20TokenAddress: ethers.constants.AddressZero,\n    tokenUriIsEnumerable: true,\n    royaltyRecipient: await beneficiary.getAddress(),\n    royaltyPercentageBps: 10,\n    maxSupply: 1000,\n    pricePerMint: pricePerMint\n    }\n);\nconst gem: SimpleEquippable = await contractFactory.deploy(\n    "Gem",\n    "GM",\n    "ipfs://collectionMeta",\n    "ipfs://tokenMeta",\n    {\n    erc20TokenAddress: ethers.constants.AddressZero,\n    tokenUriIsEnumerable: true,\n    royaltyRecipient: await beneficiary.getAddress(),\n    royaltyPercentageBps: 10,\n    maxSupply: 3000,\n    pricePerMint: pricePerMint\n    }\n);\nconst catalog: SimpleCatalog = await catalogFactory.deploy("KB", "svg");\nconst views: RMRKEquipRenderUtils = await viewsFactory.deploy();\n\nawait kanaria.deployed();\nawait gem.deployed();\nawait catalog.deployed();\nconsole.log(\n    `Sample contracts deployed to ${kanaria.address} (Kanaria), ${gem.address} (Gem) and ${catalog.address} (Catalog)`\n);\n\nreturn [kanaria, gem, catalog, views];\n}\n\nmain().catch((error) => {\nconsole.error(error);\nprocess.exitCode = 1;\n});\n```\n\nOnce the smart contracts are deployed, we can setup the Catalog. \n\nWe will set it up have two fixed part options for background, head, body and wings. Additionally we will add three slot options for gems. All of these will be added using the [`addPartList`](https://github.com/rmrk-team/evm-dev-docs/blob/master/rmrk-legos-examples/broken-reference/README.md) method. The call together with encapsulating `setupCatalog` function should look like this:\n\n```\nasync function setupCatalog(catalog: SimpleCatalog, gemAddress: string): Promise<void> {\nconsole.log("Setting up Catalog");\n// Setup catalog with 2 fixed part options for background, head, body and wings.\n// Also 3 slot options for gems\nconst tx = await catalog.addPartList([\n    {\n    // Background option 1\n    partId: 1,\n    part: {\n        itemType: 2, // Fixed\n        z: 0,\n        equippable: [],\n        metadataURI: "ipfs://backgrounds/1.svg",\n    },\n    },\n    {\n    // Background option 2\n    partId: 2,\n    part: {\n        itemType: 2, // Fixed\n        z: 0,\n        equippable: [],\n        metadataURI: "ipfs://backgrounds/2.svg",\n    },\n    },\n    {\n    // Head option 1\n    partId: 3,\n    part: {\n        itemType: 2, // Fixed\n        z: 3,\n        equippable: [],\n        metadataURI: "ipfs://heads/1.svg",\n    },\n    },\n    {\n    // Head option 2\n    partId: 4,\n    part: {\n        itemType: 2, // Fixed\n        z: 3,\n        equippable: [],\n        metadataURI: "ipfs://heads/2.svg",\n    },\n    },\n    {\n    // Body option 1\n    partId: 5,\n    part: {\n        itemType: 2, // Fixed\n        z: 2,\n        equippable: [],\n        metadataURI: "ipfs://body/1.svg",\n    },\n    },\n    {\n    // Body option 2\n    partId: 6,\n    part: {\n        itemType: 2, // Fixed\n        z: 2,\n        equippable: [],\n        metadataURI: "ipfs://body/2.svg",\n    },\n    },\n    {\n    // Wings option 1\n    partId: 7,\n    part: {\n        itemType: 2, // Fixed\n        z: 1,\n        equippable: [],\n        metadataURI: "ipfs://wings/1.svg",\n    },\n    },\n    {\n    // Wings option 2\n    partId: 8,\n    part: {\n        itemType: 2, // Fixed\n        z: 1,\n        equippable: [],\n        metadataURI: "ipfs://wings/2.svg",\n    },\n    },\n    {\n    // Gems slot 1\n    partId: 9,\n    part: {\n        itemType: 1, // Slot\n        z: 4,\n        equippable: [gemAddress], // Only gems tokens can be equipped here\n        metadataURI: "",\n    },\n    },\n    {\n    // Gems slot 2\n    partId: 10,\n    part: {\n        itemType: 1, // Slot\n        z: 4,\n        equippable: [gemAddress], // Only gems tokens can be equipped here\n        metadataURI: "",\n    },\n    },\n    {\n    // Gems slot 3\n    partId: 11,\n    part: {\n        itemType: 1, // Slot\n        z: 4,\n        equippable: [gemAddress], // Only gems tokens can be equipped here\n        metadataURI: "",\n    },\n    },\n]);\nawait tx.wait();\nconsole.log("Catalog is set");\n}\n```\n\nNOTE: The `metadataURI` of a slot can be used to retrieve a fallback asset when no asset is equipped into it.\n\nNotice how the `z` value of the background is `0` and that of the head is `3`. Also note how the `itemType` value of the `Slot` type of fixed items is `2` and that of equippable items is `1`. Additionally the `metadataURI` is usually left blank for the equippables, but has to be set for the fixed items. The `equippable` values have to be set to the gem smart contracts for the equippable items.\n\nIn order for the `setupCatalog` to be called, we have to add it to the main function:\n\n```\nawait setupCatalog(catalog, gem.address);\n```\n\nWith the `Catalog` set up, the tokens should now be minted. Both `Kanaria` and `Gem` tokens will be minted in the `mintTokens`. To define how many tokens should be minted, `totalBirds` constant will be added below the import statements:\n\n```\nconst totalBirds = 5;\n```\n\nThe `mintToken` function should accept two arguments (`Kanaria` and `Gem`). We will prepare a batch of transactions to mint the tokens and send them. Once the tokens are minted, we will output the total number of tokens minted. While the Kanaria tokens will be minted to the `tokenOwner` address, the Gem tokens will be minted using the [`nestMint`](https://github.com/rmrk-team/evm-dev-docs/blob/master/rmrk-legos-examples/broken-reference/README.md) method in order to be minted directly to the Kanaria tokens. We will mint three Gem tokens to each Kanaria. Since all of the nested tokens need to be approved, we will also build a batch of transaction to accept a single nest-minted `Gem` for each `Kanaria`:\n\n```\nasync function mintTokens(\nkanaria: SimpleEquippable,\ngem: SimpleEquippable\n): Promise<void> {\nconsole.log("Minting tokens");\nconst [ , tokenOwner] = await ethers.getSigners();\n\n// Mint some kanarias\nconsole.log("Minting Kanaria tokens");\nlet tx = await kanaria.mint(tokenOwner.address, totalBirds, {\n    value: pricePerMint.mul(totalBirds),\n});\nawait tx.wait();\nconsole.log(`Minted ${totalBirds} kanarias`);\n\n// Mint 3 gems into each kanaria\nconsole.log("Nest-minting Gem tokens");\nlet allTx: ContractTransaction[] = [];\nfor (let i = 1; i <= totalBirds; i++) {\n    let tx = await gem.nestMint(kanaria.address, 3, i, {\n    value: pricePerMint.mul(3),\n    });\n    allTx.push(tx);\n}\nawait Promise.all(allTx.map((tx) => tx.wait()));\nconsole.log(`Minted 3 gems into each kanaria`);\n\n// Accept 3 gems for each kanaria\nconsole.log("Accepting Gems");\nfor (let tokenId = 1; tokenId <= totalBirds; tokenId++) {\n    allTx = [\n    await kanaria.connect(tokenOwner).acceptChild(tokenId, 2, gem.address, 3 * tokenId),\n    await kanaria.connect(tokenOwner).acceptChild(tokenId, 1, gem.address, 3 * tokenId - 1),\n    await kanaria.connect(tokenOwner).acceptChild(tokenId, 0, gem.address, 3 * tokenId - 2),\n    ];\n}\nawait Promise.all(allTx.map((tx) => tx.wait()));\nconsole.log(`Accepted gems for each kanaria`);\n}\n```\n\nNOTE: We assign the `tokenOwner` the second available signer, so that the assets are not automatically accepted when added to the token. This happens when an account adding an asset to a token is also the owner of said token.\n\nIn order for the `mintTokens` to be called, we have to add it to the main function:\n\n```\nawait mintTokens(kanaria, gem);\n```\n\nHaving minted both `Kanarias` and `Gems`, we can now add assets to them. We will add assets to the Kanaria using the `addKanariaAssets` function. It accepts `Kanaria` and address of the `Catalog` smart contract. Assets will be added using the [`addEquippableAssetEntry`](https://github.com/rmrk-team/evm-dev-docs/blob/master/rmrk-legos-examples/broken-reference/README.md) method. We will add a default asset, which doesn\'t need a `baseAddress` value. The composed asset needs to have the baseAddress. We also specify the fixed parts IDs for background, head, body and wings. Additionally we allow the gems to be equipped in the slot parts IDs. With the asset entires added, we can add them to a token and then accept them as well:\n\n```\nasync function addKanariaAssets(\nkanaria: SimpleEquippable,\nbaseAddress: string\n): Promise<void> {\nconsole.log("Adding Kanaria assets");\nconst [ , tokenOwner] = await ethers.getSigners();\nconst assetDefaultId = 1;\nconst assetComposedId = 2;\nlet allTx: ContractTransaction[] = [];\nlet tx = await kanaria.addEquippableAssetEntry(\n    0, // Only used for assets meant to equip into others\n    ethers.constants.AddressZero, // catalog is not needed here\n    "ipfs://default.png",\n    []\n);\nallTx.push(tx);\n\ntx = await kanaria.addEquippableAssetEntry(\n    0, // Only used for assets meant to equip into others\n    catalogAddress, // Since we\'re using parts, we must define the catalog\n    "ipfs://meta1.json",\n    [1, 3, 5, 7, 9, 10, 11] // We\'re using first background, head, body and wings and state that this can receive the 3 slot parts for gems\n);\nallTx.push(tx);\n// Wait for both assets to be added\nawait Promise.all(allTx.map((tx) => tx.wait()));\nconsole.log("Added 2 asset entries");\n\n// Add assets to token\nconst tokenId = 1;\nallTx = [\n    await kanaria.addAssetToToken(tokenId, assetDefaultId, 0),\n    await kanaria.addAssetToToken(tokenId, assetComposedId, 0),\n];\nawait Promise.all(allTx.map((tx) => tx.wait()));\nconsole.log("Added assets to token 1");\n\n// Accept both assets:\ntx = await kanaria.connect(tokenOwner).acceptAsset(tokenId, 0, assetDefaultId);\nawait tx.wait();\ntx = await kanaria.connect(tokenOwner).acceptAsset(tokenId, 0, assetComposedId);\nawait tx.wait();\nconsole.log("Assets accepted");\n}\n```\n')))}c.isMDXComponent=!0}}]);